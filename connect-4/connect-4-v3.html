<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 Advanced - Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for the document and theme variables */
        :root {
            --background-light: #f3f4f6;
            --text-light: #1f2937;
            --board-bg-light: #4b5563;
            --background-dark: #1f2937;
            --text-dark: #f3f4f6;
            --board-bg-dark: #374151;
        }

        body {
            font-family: 'Inter', sans-serif;
        }

        /* Dark theme variables */
        .dark {
            --background: var(--background-dark);
            --text: var(--text-dark);
            --board-bg: var(--board-bg-dark);
        }

        /* Light theme variables */
        .light {
            --background: var(--background-light);
            --text: var(--text-light);
            --board-bg: var(--board-bg-light);
        }

        /* The .hole div is no longer used for visual holes, so hide it */
        .hole {
            display: none;
        }

        /* Styling for each cell on the game board (now just interactive areas) */
        .cell {
            position: relative;
            /* Crucial for positioning landed discs inside */
            border-radius: 3px;
            overflow: hidden;
            /* Clips content outside cell boundary */
            /* No background or z-index here, as it's handled by other layers */
        }

        /* Styling for a disc (after landing) */
        .disc {
            width: 83%;
            height: 83%;
            border-radius: 50%;
            /* border: 2px solid rgba(255, 255, 255, 0.3); */
            /* box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.2), inset 0 -2px 4px rgba(0, 0, 0, 0.2), 0 2px 4px rgba(0, 0, 0, 0.1); */
            position: absolute;
            /* Positioned within its parent cell */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: -1;
            /* Disc is now above the board visual layer (z-index: 1) */
        }

        /* Styling for the disc during the falling animation */
        .falling-disc {
            position: absolute;
            pointer-events: none;
            transform-origin: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            /* z-index is controlled by its parent #falling-disc-layer */
        }

        /* Highlight for columns on hover */
        .column-highlight {
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        /* Hover effect for column highlight */
        .column-highlight:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Modal backdrop for pop-ups */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        /* Content area for modals */
        .modal-content {
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw;
        }

        /* Styling for the game board container - the main wrapper */
        #game-board-container {
            border: 4px solid #2d3748;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            /* Crucial for absolute positioning of children layers */
            /* No background-color here, it's on #board-visual-layer */
        }

        /* Layer for falling discs only */
        #falling-disc-layer {
            /* Renamed from falling-disc-animation-layer */
            position: absolute;
            inset: 0;
            /* Covers the entire parent container */
            overflow: hidden;
            /* Clips discs if they go outside */
            z-index: 0;
            /* Lowest layer, behind the board visual */
        }

        /* Layer for the board visual with holes (the mask will be here) */
        #board-visual-layer {
            position: absolute;
            inset: 0;
            /* Covers the entire parent container */
            z-index: 1;
            /* Above the falling disc layer */
            background-color: var(--board-bg);
            /* The solid board color */

            /* CSS Masking Properties */
            mask-image: none;
            /* Will be set dynamically by JS */
            mask-mode: alpha;
            mask-composite: exclude;
            /* Subtracts new masks from previous */
            -webkit-mask-image: none;
            -webkit-mask-mode: alpha;
            -webkit-mask-composite: exclude;
        }

        /* The interactive grid (cells for click events) - no visual background */
        #game-board {
            position: relative;
            /* Positioned relative to #game-board-container */
            inset: 0;
            /* Covers the entire parent container */
            z-index: 2;
            /* Above the board visual layer, for clickability */
            padding: 12px;
            /* p-2 in Tailwind is 0.5rem = 8px; crucial for JS calculations */
            height: 100%;
            display: grid;
            gap: 10px;
            /* gap-1 in Tailwind */
            /* No background-color or mask here */
        }

        /* Screen reader only text */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus styles for interactive elements */
        .focus-visible:focus {
            background-color: #f0f0f075;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .modal-content {
                padding: 1.5rem;
                margin: 1rem;
            }

            #game-board-container {
                max-width: 100%;
                margin: 0 auto;
            }
        }

        /* Keyboard navigation focus style */
        .keyboard-focus {
            background-color: #f0f0f075;
        }

        .cell.aspect-square.flex.justify-center.items-center {
            border-radius: 50%;
            box-shadow: inset -5px -10px 10px rgba(0, 0, 0, 0.3), 0px 0px 0px rgba(0, 0, 0, 0.2);
            /* border: 3px solid #4646466e; */
        }

        #board-visual-layer {
            position: absolute;
            inset: 0;
            z-index: 1;

        }
    </style>
</head>

<body class="light bg-[var(--background)] text-[var(--text)] transition-colors duration-300" role="main">

    <div class="container mx-auto p-4 flex flex-col lg:flex-row gap-8">
        <!-- Game Board and Info -->
        <main class="w-full lg:w-2/3">
            <h1 class="text-4xl font-bold text-center mb-4">Connect 4</h1>

            <div id="game-info" class="text-center mb-4 h-16 flex flex-col items-center justify-center">
                <p id="status-message" class="text-xl font-medium" aria-live="polite"></p>
                <p id="timer-display" class="text-sm text-gray-600 dark:text-gray-400" aria-live="polite"></p>
            </div>

            <div id="game-board-container" class="mx-auto aspect-[7/6] max-w-full rounded-lg shadow-lg">

                <!-- Layer for falling discs only -->
                <div id="falling-disc-layer" class="absolute inset-0 overflow-hidden"></div>

                <!-- Layer for the board visual with holes (the mask will be here) -->
                <div id="board-visual-layer" class="absolute inset-0"></div>

                <!-- The interactive grid (cells for click events) - no visual background -->
                <div id="game-board" class="h-full" role="grid" aria-label="Connect 4 game board">
                    <!-- Game board cells (now just invisible click targets) will be generated here -->
                </div>
            </div>

            <div id="game-controls" class="flex flex-wrap justify-center gap-4 mt-4">
                <button id="pause-btn"
                    class="px-4 py-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 focus-visible:focus transition-colors"
                    aria-label="Pause game">
                    Pause
                </button>
                <button id="undo-btn"
                    class="px-4 py-2 bg-orange-500 text-white rounded-lg shadow hover:bg-orange-600 focus-visible:focus transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    aria-label="Undo last move" disabled>
                    Undo
                </button>
                <button id="hint-btn"
                    class="px-4 py-2 bg-purple-500 text-white rounded-lg shadow hover:bg-purple-600 focus-visible:focus transition-colors"
                    aria-label="Get hint">
                    Hint
                </button>
                <button id="save-btn"
                    class="px-4 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 focus-visible:focus transition-colors"
                    aria-label="Save current game">
                    Save Game
                </button>
                <label
                    class="px-4 py-2 bg-yellow-500 text-white rounded-lg shadow hover:bg-yellow-600 cursor-pointer focus-within:ring-2 focus-within:ring-yellow-300 transition-colors">
                    Load Game
                    <input type="file" id="load-game-input" class="sr-only" accept=".json" aria-label="Load saved game">
                </label>
            </div>

            <div id="move-history" class="mt-4 text-center">
                <h3 class="text-lg font-semibold mb-2">Move History</h3>
                <div id="history-list" class="text-sm text-gray-600 dark:text-gray-400 max-h-32 overflow-y-auto">
                    <!-- Move history will appear here -->
                </div>
            </div>
        </main>

        <!-- Settings Panel -->
        <aside
            class="w-full lg:w-1/3 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100 p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-bold mb-4 border-b pb-2">Game Settings</h2>

            <!-- Theme Settings -->
            <div class="mb-4">
                <label class="block font-medium mb-2">Theme</label>
                <div class="flex gap-2">
                    <button id="light-mode-btn"
                        class="flex-1 px-4 py-2 bg-gray-200 text-gray-900 rounded-lg focus-visible:focus transition-colors">Light</button>
                    <button id="dark-mode-btn"
                        class="flex-1 px-4 py-2 bg-gray-700 text-white rounded-lg focus-visible:focus transition-colors">Dark</button>
                </div>
            </div>

            <!-- Board Color -->
            <div class="mb-4">
                <label for="board-color" class="block font-medium mb-1">Board Color</label>
                <select id="board-color"
                    class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                    <option value="#4b5563">Gray</option>
                    <option value="#3b82f6">Blue</option>
                    <option value="#8b5cf6">Purple</option>
                    <option value="#059669">Green</option>
                </select>
            </div>

            <!-- Game Mode -->
            <div class="mb-4">
                <label for="game-mode" class="block font-medium mb-1">Game Mode</label>
                <select id="game-mode" class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                    <option value="classic">Classic</option>
                    <option value="timed">Timed</option>
                    <option value="fixed_turn">Fixed Turn</option>
                </select>
            </div>

            <!-- Timed Mode Options -->
            <div id="timed-options" class="hidden mb-4 pl-4 border-l-2 border-blue-300">
                <label for="time-limit" class="block font-medium mb-1">Game Time Limit</label>
                <select id="time-limit"
                    class="w-full p-2 rounded bg-white dark:bg-gray-700 border mb-2 focus-visible:focus">
                    <option value="120">2 minutes</option>
                    <option value="300">5 minutes</option>
                    <option value="600">10 minutes</option>
                    <option value="1200">20 minutes</option>
                </select>
                <label for="turn-time-limit" class="block font-medium mb-1">Turn Time Limit</label>
                <select id="turn-time-limit"
                    class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                    <option value="0">No Limit</option>
                    <option value="10">10 seconds</option>
                    <option value="15">15 seconds</option>
                    <option value="30">30 seconds</option>
                </select>
            </div>

            <!-- Fixed Turn Options -->
            <div id="fixed-turn-options" class="hidden mb-4 pl-4 border-l-2 border-green-300">
                <label for="turn-limit" class="block font-medium mb-1">Turns per Player</label>
                <input type="number" id="turn-limit" value="15" min="5" max="50"
                    class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
            </div>

            <!-- Player Setup -->
            <div class="mb-4">
                <label for="player-mode" class="block font-medium mb-1">Players</label>
                <select id="player-mode"
                    class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                    <option value="vs_com">vs Computer</option>
                    <option value="2_player">2 Players</option>
                    <option value="3_player">3 Players</option>
                    <option value="4_player">4 Players</option>
                </select>
            </div>

            <!-- AI Settings -->
            <div id="ai-settings-container" class="mb-4 pl-4 border-l-2 border-red-300">
                <!-- AI difficulty settings will be generated here -->
            </div>

            <!-- Player Colors -->
            <div id="player-colors-container" class="mb-4 space-y-2">
                <!-- Player color inputs will be generated here -->
            </div>

            <!-- Board Size -->
            <div class="mb-4">
                <label class="block font-medium mb-1">Board Size</label>
                <div class="flex gap-2 items-center">
                    <input type="number" id="board-cols" value="7" min="4" max="15"
                        class="w-1/2 p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus"
                        aria-label="Number of columns">
                    <span>×</span>
                    <input type="number" id="board-rows" value="6" min="4" max="15"
                        class="w-1/2 p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus"
                        aria-label="Number of rows">
                </div>
                <p class="text-xs text-gray-500 mt-1">Columns × Rows (4-15 each)</p>
            </div>

            <!-- Win Condition -->
            <div class="mb-4">
                <label for="win-condition" class="block font-medium mb-1">Discs to Win</label>
                <input type="number" id="win-condition" value="4" min="3" max="8"
                    class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                <p class="text-xs text-gray-500 mt-1">Must be ≤ smallest board dimension</p>
            </div>

            <!-- Diagonal Match -->
            <div class="mb-6 flex items-center gap-2">
                <input type="checkbox" id="enable-diagonal" class="h-5 w-5 rounded focus-visible:focus" checked>
                <label for="enable-diagonal">Enable Diagonal Matches</label>
            </div>

            <button id="start-game-btn"
                class="w-full px-4 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 focus-visible:focus transition-all transform hover:scale-105">
                Start New Game
            </button>
        </aside>
    </div>

    <!-- Modal for Winner/Draw -->
    <div id="winner-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true"
        aria-labelledby="winner-message">
        <div class="modal-content bg-[var(--background)] text-[var(--text)] text-center">
            <h3 id="winner-message" class="text-3xl font-bold mb-4"></h3>
            <div class="flex gap-4 justify-center">
                <button id="play-again-btn"
                    class="px-6 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 focus-visible:focus transition-colors">
                    Play Again
                </button>
                <button id="close-modal-btn"
                    class="px-6 py-2 bg-gray-500 text-white rounded-lg shadow hover:bg-gray-600 focus-visible:focus transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants ---
            const SAVE_FILE_VERSION = "1.0";
            const DEFAULT_PLAYER_COLORS = ['#ef4444', '#3b82f6', '#f59e0b', '#10b981'];
            const ANIMATION_DURATION = 500; // milliseconds

            // --- DOM Elements ---
            const elements = {
                gameBoard: document.getElementById('game-board'), // Now the interactive grid
                statusMessage: document.getElementById('status-message'),
                timerDisplay: document.getElementById('timer-display'),
                boardContainer: document.getElementById('game-board-container'),
                winnerModal: document.getElementById('winner-modal'),
                winnerMessage: document.getElementById('winner-message'),
                historyList: document.getElementById('history-list'),
                fallingDiscLayer: document.getElementById('falling-disc-layer'), // Renamed
                boardVisualLayer: document.getElementById('board-visual-layer'), // Reference to the board visual layer
                // discLayer: document.getElementById('disc-layer'), // No longer needed for landed discs

                // Settings
                lightModeBtn: document.getElementById('light-mode-btn'),
                darkModeBtn: document.getElementById('dark-mode-btn'),
                boardColorSelect: document.getElementById('board-color'),
                gameModeSelect: document.getElementById('game-mode'),
                timedOptions: document.getElementById('timed-options'),
                timeLimitSelect: document.getElementById('time-limit'),
                turnTimeLimitSelect: document.getElementById('turn-time-limit'),
                fixedTurnOptions: document.getElementById('fixed-turn-options'),
                turnLimitInput: document.getElementById('turn-limit'),
                playerModeSelect: document.getElementById('player-mode'),
                aiSettingsContainer: document.getElementById('ai-settings-container'),
                playerColorsContainer: document.getElementById('player-colors-container'),
                boardColsInput: document.getElementById('board-cols'),
                boardRowsInput: document.getElementById('board-rows'),
                winConditionInput: document.getElementById('win-condition'),
                enableDiagonalCheckbox: document.getElementById('enable-diagonal'),
                startGameBtn: document.getElementById('start-game-btn'),

                // Controls
                pauseBtn: document.getElementById('pause-btn'),
                undoBtn: document.getElementById('undo-btn'),
                hintBtn: document.getElementById('hint-btn'),
                saveBtn: document.getElementById('save-btn'),
                loadGameInput: document.getElementById('load-game-input'),
                playAgainBtn: document.getElementById('play-again-btn'),
                closeModalBtn: document.getElementById('close-modal-btn')
            };

            // --- Game State ---
            let gameState = {};
            let currentFocusedColumn = 0;

            function getDefaultGameState() {
                return {
                    version: SAVE_FILE_VERSION,
                    board: [],
                    players: [],
                    currentPlayerIndex: 0,
                    gameOver: false,
                    isPaused: false,
                    winner: null,
                    winningCells: [],
                    moveHistory: [],
                    lastHintColumn: -1,

                    settings: {
                        rows: 6,
                        cols: 7,
                        winCondition: 4,
                        enableDiagonal: true,
                        gameMode: 'classic',
                        timeLimit: 120,
                        turnTimeLimit: 0,
                        turnLimit: 15,
                        playerMode: 'vs_com',
                    },

                    timers: {
                        gameTimerId: null,
                        turnTimerId: null,
                        remainingGameTime: 120,
                        remainingTurnTime: 0,
                        gamePaused: false,
                        turnPaused: false,
                    },

                    turnsTaken: [],
                };
            }

            // --- Utility Functions ---
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            function validateSettings() {
                const rows = parseInt(elements.boardRowsInput.value);
                const cols = parseInt(elements.boardColsInput.value);
                const winCondition = parseInt(elements.winConditionInput.value);

                if (rows < 4 || rows > 15 || cols < 4 || cols > 15) {
                    alert('Board dimensions must be between 4 and 15');
                    return false;
                }

                if (winCondition < 3 || winCondition > Math.min(rows, cols)) {
                    alert(`Win condition must be between 3 and ${Math.min(rows, cols)} (the smallest board dimension)`);
                    return false;
                }
                return true;
            }

            function moveColumnFocus(direction) {
                currentFocusedColumn += direction;
                if (currentFocusedColumn < 0) currentFocusedColumn = gameState.settings.cols - 1;
                if (currentFocusedColumn >= gameState.settings.cols) currentFocusedColumn = 0;
                updateColumnHighlight();
            }

            function updateColumnHighlight() {
                document.querySelectorAll('.keyboard-focus').forEach(el => {
                    el.classList.remove('keyboard-focus');
                });
                for (let r = 0; r < gameState.settings.rows; r++) {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${currentFocusedColumn}']`);
                    if (cell) {
                        cell.classList.add('keyboard-focus');
                    }
                }
            }

            function getUniqueColors() {
                const playerCount = getPlayerCount();
                const colors = [];
                const usedColors = new Set();

                for (let i = 0; i < playerCount; i++) {
                    const input = document.getElementById(`player-${i + 1}-color`);
                    let color = input ? input.value : DEFAULT_PLAYER_COLORS[i];
                    let counter = 0;
                    while (usedColors.has(color) && counter < 10) {
                        const hue = Math.floor(Math.random() * 360);
                        color = `hsl(${hue}, 70%, 50%)`;
                        counter++;
                    }
                    if (counter >= 10) {
                        color = DEFAULT_PLAYER_COLORS[i % DEFAULT_PLAYER_COLORS.length];
                    }
                    colors.push(color);
                    usedColors.add(color);
                }
                return colors;
            }

            // --- Initialization ---
            function init() {
                gameState = getDefaultGameState();
                updatePlayerInputs();
                setupEventListeners();
                startGame();
            }

            function setupEventListeners() {
                // Theme
                elements.lightModeBtn.addEventListener('click', () => {
                    document.body.className = 'light bg-[var(--background)] text-[var(--text)] transition-colors duration-300';
                });
                elements.darkModeBtn.addEventListener('click', () => {
                    document.body.className = 'dark bg-[var(--background)] text-[var(--text)] transition-colors duration-300';
                });

                // Settings
                elements.boardColorSelect.addEventListener('change', (e) => {
                    // Board background is now on #board-visual-layer
                    elements.boardVisualLayer.style.backgroundColor = e.target.value;
                });
                elements.gameModeSelect.addEventListener('change', updateGameModeOptionsVisibility);
                elements.playerModeSelect.addEventListener('change', updatePlayerInputs);
                elements.startGameBtn.addEventListener('click', startGame);

                // Validation
                const debouncedValidation = debounce(() => {
                    validateInputs();
                }, 300);
                [elements.boardRowsInput, elements.boardColsInput, elements.winConditionInput].forEach(input => {
                    input.addEventListener('input', debouncedValidation);
                });

                // Controls
                elements.pauseBtn.addEventListener('click', togglePause);
                elements.undoBtn.addEventListener('click', undoMove);
                elements.hintBtn.addEventListener('click', showHint);
                elements.saveBtn.addEventListener('click', saveGame);
                elements.loadGameInput.addEventListener('change', loadGame);
                elements.playAgainBtn.addEventListener('click', () => {
                    elements.winnerModal.classList.add('hidden');
                    startGame();
                });
                elements.closeModalBtn.addEventListener('click', () => {
                    elements.winnerModal.classList.add('hidden');
                });

                // Keyboard support
                document.addEventListener('keydown', handleKeyboard);

                // Prevent accidental page refresh
                window.addEventListener('beforeunload', (e) => {
                    if (!gameState.gameOver && gameState.moveHistory.length > 0) {
                        e.preventDefault();
                        e.returnValue = '';
                    }
                });
            }

            function handleKeyboard(e) {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return;

                if (e.key >= '1' && e.key <= '9') {
                    const col = parseInt(e.key) - 1;
                    if (col < gameState.settings.cols) makeMove(col);
                } else if (e.key === ' ') {
                    e.preventDefault();
                    togglePause();
                } else if (e.key === 'h' || e.key === 'H') {
                    showHint();
                } else if (e.key === 'u' || e.key === 'U') {
                    undoMove();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    moveColumnFocus(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    moveColumnFocus(1);
                } else if (e.key === 'ArrowDown' || e.key === 'Enter') {
                    e.preventDefault();
                    makeMove(currentFocusedColumn);
                }
            }

            function updateGameModeOptionsVisibility() {
                const mode = elements.gameModeSelect.value;
                elements.timedOptions.classList.toggle('hidden', mode !== 'timed');
                elements.fixedTurnOptions.classList.toggle('hidden', mode !== 'fixed_turn');
            }

            function updatePlayerInputs() {
                updatePlayerColorInputs();
                updateAISettings();
            }

            function updatePlayerColorInputs() {
                elements.playerColorsContainer.innerHTML = '';
                const playerCount = getPlayerCount();
                for (let i = 0; i < playerCount; i++) {
                    const playerType = getPlayerType(i);
                    const label = document.createElement('label');
                    label.className = 'block font-medium mb-1';
                    label.textContent = `${playerType} Color`;
                    const input = document.createElement('input');
                    input.type = 'color';
                    input.id = `player-${i + 1}-color`;
                    input.className = 'w-full p-1 h-10 block border rounded focus-visible:focus';
                    input.value = gameState.players && gameState.players[i] ?
                        gameState.players[i].color : DEFAULT_PLAYER_COLORS[i];
                    elements.playerColorsContainer.appendChild(label);
                    elements.playerColorsContainer.appendChild(input);
                }
            }

            function updateAISettings() {
                elements.aiSettingsContainer.innerHTML = '';
                if (elements.playerModeSelect.value === 'vs_com') {
                    elements.aiSettingsContainer.classList.remove('hidden');
                    const label = document.createElement('label');
                    label.className = 'block font-medium mb-1';
                    label.textContent = 'AI Difficulty';
                    const select = document.createElement('select');
                    select.id = 'ai-difficulty';
                    select.className = 'w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus';
                    ['easy', 'medium', 'hard'].forEach(difficulty => {
                        const option = document.createElement('option');
                        option.value = difficulty;
                        option.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                        select.appendChild(option);
                    });
                    elements.aiSettingsContainer.appendChild(label);
                    elements.aiSettingsContainer.appendChild(select);
                } else {
                    elements.aiSettingsContainer.classList.add('hidden');
                }
            }

            function getPlayerCount() {
                const mode = elements.playerModeSelect.value;
                switch (mode) {
                    case 'vs_com':
                    case '2_player':
                        return 2;
                    case '3_player':
                        return 3;
                    case '4_player':
                        return 4;
                    default:
                        return 2;
                }
            }

            function getPlayerType(index) {
                if (elements.playerModeSelect.value === 'vs_com' && index === 1) {
                    return 'Computer';
                }
                return `Player ${index + 1}`;
            }

            function validateInputs() {
                const rows = parseInt(elements.boardRowsInput.value);
                const cols = parseInt(elements.boardColsInput.value);
                const winCondition = parseInt(elements.winConditionInput.value);
                if (winCondition > Math.min(rows, cols)) {
                    elements.winConditionInput.value = Math.min(rows, cols);
                }
            }

            // --- Game Logic ---
            function startGame() {
                if (!validateSettings()) return;
                cleanupGame();
                gameState = getDefaultGameState();

                // Apply settings
                gameState.settings.rows = parseInt(elements.boardRowsInput.value);
                gameState.settings.cols = parseInt(elements.boardColsInput.value);
                gameState.settings.winCondition = parseInt(elements.winConditionInput.value);
                gameState.settings.enableDiagonal = elements.enableDiagonalCheckbox.checked;
                gameState.settings.gameMode = elements.gameModeSelect.value;
                gameState.settings.timeLimit = parseInt(elements.timeLimitSelect.value);
                gameState.settings.turnTimeLimit = parseInt(elements.turnTimeLimitSelect.value);
                gameState.settings.turnLimit = parseInt(elements.turnLimitInput.value);
                gameState.settings.playerMode = elements.playerModeSelect.value;

                // Initialize players
                const playerCount = getPlayerCount();
                const colors = getUniqueColors();
                gameState.players = [];
                gameState.turnsTaken = [];
                for (let i = 0; i < playerCount; i++) {
                    const isAI = elements.playerModeSelect.value === 'vs_com' && i === 1;
                    gameState.players.push({
                        id: i + 1,
                        name: getPlayerType(i),
                        color: colors[i],
                        isAI: isAI,
                        difficulty: isAI ? document.getElementById('ai-difficulty')?.value || 'medium' : null,
                    });
                    gameState.turnsTaken.push(0);
                }

                // Initialize board
                gameState.board = Array(gameState.settings.rows).fill(null).map(() =>
                    Array(gameState.settings.cols).fill(0)
                );

                // Set initial board color on the visual layer
                elements.boardVisualLayer.style.backgroundColor = elements.boardColorSelect.value;


                // Setup timers
                if (gameState.settings.gameMode === 'timed') {
                    gameState.timers.remainingGameTime = gameState.settings.timeLimit;
                    gameState.timers.remainingTurnTime = gameState.settings.turnTimeLimit;
                }

                renderBoard(); // Call renderBoard after all settings are applied
                updateDisplay();
                elements.winnerModal.classList.add('hidden');
                elements.undoBtn.disabled = true;
                elements.historyList.innerHTML = '';

                if (gameState.settings.gameMode === 'timed') {
                    startGameTimer();
                }
                nextTurn();
                currentFocusedColumn = Math.floor(gameState.settings.cols / 2);
                updateColumnHighlight();
            }

            function cleanupGame() {
                if (gameState && gameState.timers) {
                    clearTimers();
                }
                // Clear any existing falling discs from the falling disc layer
                if (elements.fallingDiscLayer) {
                    elements.fallingDiscLayer.innerHTML = '';
                }
            }

            function renderBoard() {
                elements.gameBoard.innerHTML = ''; // Clear interactive cells
                // No longer clearing discLayer, as discs are children of cells now

                elements.gameBoard.style.gridTemplateColumns = `repeat(${gameState.settings.cols}, 1fr)`;
                elements.gameBoard.style.gridTemplateRows = `repeat(${gameState.settings.rows}, 1fr)`;

                // Get computed styles for accurate measurements from the interactive grid
                const boardComputedStyle = window.getComputedStyle(elements.gameBoard);
                const boardPaddingLeft = parseFloat(boardComputedStyle.paddingLeft);
                const boardPaddingTop = parseFloat(boardComputedStyle.paddingTop);
                const gap = 4; // Tailwind's gap-1 is typically 0.25rem = 4px

                // Calculate effective board content dimensions
                const boardContentWidth = elements.gameBoard.clientWidth - boardPaddingLeft - parseFloat(boardComputedStyle.paddingRight);
                const boardContentHeight = elements.gameBoard.clientHeight - boardPaddingTop - parseFloat(boardComputedStyle.paddingBottom);

                const cellWidth = (boardContentWidth - (gameState.settings.cols - 1) * gap) / gameState.settings.cols;
                const cellHeight = (boardContentHeight - (gameState.settings.rows - 1) * gap) / gameState.settings.rows;

                const discDiameter = cellWidth * 0.85; // Diameter of the disc
                const holeRadius = discDiameter / 2; // Radius of the hole

                const maskGradients = [];
                // Start with a solid black background for the mask. This is the base that will be "cut out".
                maskGradients.push('linear-gradient(black, black)');

                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        // Calculate center of each hole relative to #game-board (which is also the coordinate system for boardVisualLayer)
                        const xCenter = boardPaddingLeft + c * (cellWidth + gap) + cellWidth / 2;
                        const yCenter = boardPaddingTop + r * (cellHeight + gap) + cellHeight / 2;

                        // For 'exclude', we want to subtract an opaque circle (black) from the base.
                        // So, the gradient should be black inside the hole, and transparent outside.
                        // Use hard stops for sharp edges.
                        maskGradients.push(`radial-gradient(circle ${holeRadius}px at ${xCenter}px ${yCenter}px, black ${holeRadius * 0.95}px, transparent ${holeRadius * 1}px)`);

                        // Create interactive cell (no visual, just for clicks/hover)
                        const cell = document.createElement('div');
                        cell.className = 'cell aspect-square flex justify-center items-center';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `Row ${r + 1}, Column ${c + 1}`);

                        // Add click/hover listeners to top row cells
                        if (r === 0) {
                            cell.addEventListener('click', () => handleCellClick(c));
                            cell.addEventListener('mouseenter', () => highlightColumn(c, true));
                            cell.addEventListener('mouseleave', () => highlightColumn(c, false));
                            cell.tabIndex = 0;
                            cell.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter' || e.key === ' ') {
                                    e.preventDefault();
                                    handleCellClick(c);
                                }
                            });
                        }
                        elements.gameBoard.appendChild(cell);

                        // If a disc exists, create it and append to the cell
                        const playerOwner = gameState.board[r][c];
                        if (playerOwner > 0) {
                            const disc = document.createElement('div');
                            disc.className = 'disc';
                            disc.style.backgroundColor = gameState.players[playerOwner - 1].color;
                            disc.setAttribute('aria-label', `${gameState.players[playerOwner - 1].name} disc`);

                            // Append landed disc directly to the cell
                            cell.appendChild(disc);
                        }
                    }
                }

                // Apply the mask to the board visual layer
                const maskValue = maskGradients.join(', ');
                elements.boardVisualLayer.style.maskImage = maskValue;
                elements.boardVisualLayer.style.webkitMaskImage = maskValue;

                highlightWinningCells();
            }

            function highlightColumn(col, highlight) {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return;
                for (let r = 0; r < gameState.settings.rows; r++) {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${col}']`);
                    if (cell) {
                        if (highlight && getNextAvailableRow(col) !== -1) {
                            cell.classList.add('column-highlight');
                        } else {
                            cell.classList.remove('column-highlight');
                        }
                    }
                }
            }

            function highlightWinningCells() {
                gameState.winningCells.forEach(([r, c]) => {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${c}']`);
                    const disc = cell?.querySelector('.disc'); // Find the disc within the cell
                    if (disc) {
                        disc.classList.add('winning-disc');
                    }
                });
            }

            function handleCellClick(col) {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return;
                makeMove(col);
            }

            function makeMove(col) {
                if (gameState.gameOver) return;
                const row = getNextAvailableRow(col);
                if (row === -1) return;

                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                setInteractionState(false);

                gameState.moveHistory.push({
                    player: gameState.currentPlayerIndex,
                    col: col,
                    row: row,
                    boardState: gameState.board.map(row => [...row])
                });

                animateDiscDrop(col, row, currentPlayer.color, () => {
                    gameState.board[row][col] = currentPlayer.id; // Update board state
                    renderBoard(); // Re-render the board to place the landed disc correctly in its cell
                    updateMoveHistory();
                    elements.undoBtn.disabled = false;

                    const winner = checkWin(row, col);
                    if (winner) {
                        endGame(`${winner.name} wins!`, winner);
                        return;
                    }

                    if (isBoardFull()) {
                        endGame("It's a draw!");
                        return;
                    }

                    if (gameState.settings.gameMode === 'fixed_turn' && checkFixedTurnEnd()) {
                        const result = determineFixedTurnWinner();
                        endGame(result.message, result.result);
                        return;
                    }

                    nextTurn();
                    setInteractionState(true);
                });
            }

            function animateDiscDrop(col, targetRow, color, callback) {
                // Get board's computed styles for accurate measurements
                const boardComputedStyle = window.getComputedStyle(elements.gameBoard);
                const boardPaddingLeft = parseFloat(boardComputedStyle.paddingLeft);
                const boardPaddingRight = parseFloat(boardComputedStyle.paddingRight);
                const gap = 4; // Assumes Tailwind's gap-1

                // Calculate effective board content width
                const boardContentWidth = elements.gameBoard.clientWidth - boardPaddingLeft - boardPaddingRight;
                // Calculate individual cell width
                const cellWidth = (boardContentWidth - (gameState.settings.cols - 1) * gap) / gameState.settings.cols;

                // Calculate disc's horizontal center relative to board's content area
                const discLeft = boardPaddingLeft + col * (cellWidth + gap) + cellWidth / 2;
                // Calculate disc size (85% of cell)
                const discSize = cellWidth * 0.85;

                // Create falling disc element
                const fallingDisc = document.createElement('div');
                fallingDisc.className = 'falling-disc disc';
                fallingDisc.style.backgroundColor = color;
                fallingDisc.style.width = `${discSize}px`;
                fallingDisc.style.height = `${discSize}px`;

                // Set disc's initial position (above board, horizontally centered)
                fallingDisc.style.left = `${discLeft}px`;
                fallingDisc.style.top = `-${discSize * 2}px`; // Start well above the board
                fallingDisc.style.transform = 'translate(-50%, -50%)'; // Center disc's own dimensions

                fallingDisc.style.boxShadow = '0 4px 8px rgba(0,0,0,0.4)';

                // IMPORTANT: Append to the falling disc layer
                elements.fallingDiscLayer.appendChild(fallingDisc);

                // Get target cell's vertical position for landing
                const targetCell = elements.gameBoard.querySelector(`[data-row='${targetRow}'][data-col='${col}']`);
                const targetCellRect = targetCell.getBoundingClientRect();
                const boardRect = elements.gameBoard.getBoundingClientRect(); // Rect of #game-board

                // Calculate target vertical center relative to board
                const targetTop = (targetCellRect.top + targetCellRect.height / 2) - boardRect.top;

                // Calculate fall time based on distance
                const startTop = parseFloat(fallingDisc.style.top);
                const fallDistance = targetTop - startTop;
                const fallTime = Math.min(800, Math.max(300, fallDistance * 1.5));

                // Animate main fall with a subtle ease-out
                fallingDisc.style.transition = `top ${fallTime}ms ease-out`;

                // Start fall
                requestAnimationFrame(() => {
                    fallingDisc.style.top = `${targetTop}px`;
                });

                // Handle landing bounce
                setTimeout(() => {
                    // Small upward bounce
                    fallingDisc.style.transition = 'top 150ms ease-out';
                    fallingDisc.style.top = `${targetTop - 1}px`;

                    setTimeout(() => {
                        // Settle down
                        fallingDisc.style.transition = 'top 100ms ease-in';
                        fallingDisc.style.top = `${targetTop}px`;

                        setTimeout(() => {
                            // Remove falling disc and call callback
                            fallingDisc.remove();
                            // Re-render the board to place the landed disc correctly
                            renderBoard();
                            callback();
                        }, 100);
                    }, 150);
                }, fallTime);
            }

            function setInteractionState(enabled) {
                elements.gameBoard.style.pointerEvents = enabled ? 'auto' : 'none';
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.tabIndex = enabled ? 0 : -1;
                });
            }

            function getNextAvailableRow(col) {
                for (let r = gameState.settings.rows - 1; r >= 0; r--) {
                    if (gameState.board[r][col] === 0) {
                        return r;
                    }
                }
                return -1;
            }

            function isBoardFull() {
                return gameState.board[0].every(cell => cell !== 0);
            }

            function checkWin(r, c) {
                const playerId = gameState.board[r][c];
                const winLength = gameState.settings.winCondition;
                const directions = [
                    [0, 1], // horizontal
                    [1, 0], // vertical
                    [1, 1], // diagonal /
                    [1, -1] // diagonal \
                ];

                for (const [dr, dc] of directions) {
                    if (!gameState.settings.enableDiagonal && (dr === 1 && dc !== 0)) continue;
                    const cells = [];
                    for (let dir = -1; dir <= 1; dir += 2) {
                        for (let i = 1; i < winLength; i++) {
                            const nr = r + dr * i * dir;
                            const nc = c + dc * i * dir;
                            if (nr >= 0 && nr < gameState.settings.rows &&
                                nc >= 0 && nc < gameState.settings.cols &&
                                gameState.board[nr][nc] === playerId) {
                                cells.push([nr, nc]);
                            } else {
                                break;
                            }
                        }
                    }
                    cells.push([r, c]);
                    if (cells.length >= winLength) {
                        gameState.winningCells = cells.slice(0, winLength);
                        return gameState.players[playerId - 1];
                    }
                }
                return null;
            }

            function checkFixedTurnEnd() {
                return gameState.turnsTaken.every(turns => turns >= gameState.settings.turnLimit);
            }

            function determineFixedTurnWinner() {
                const discCounts = Array(gameState.players.length).fill(0);
                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        if (gameState.board[r][c] > 0) {
                            discCounts[gameState.board[r][c] - 1]++;
                        }
                    }
                }
                const maxDiscs = Math.max(...discCounts);
                const winners = gameState.players.filter((p, i) => discCounts[i] === maxDiscs);
                if (winners.length > 1) {
                    return {
                        message: "It's a draw!",
                        winner: null
                    };
                } else {
                    return {
                        message: `${winners[0].name} wins with ${maxDiscs} discs!`,
                        winner: winners[0]
                    };
                }
            }

            function nextTurn() {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                gameState.lastHintColumn = -1;
                updateDisplay();
                if (gameState.settings.gameMode === 'timed' && gameState.settings.turnTimeLimit > 0) {
                    resetTurnTimer();
                    startTurnTimer();
                }
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (!gameState.gameOver && currentPlayer.isAI) {
                    setTimeout(() => aiMove(currentPlayer.difficulty), 1000);
                }
            }

            function endGame(message, winner = null) {
                gameState.gameOver = true;
                gameState.winner = winner;
                clearTimers();
                if (winner) highlightWinningCells();
                elements.winnerMessage.textContent = message;
                elements.winnerModal.classList.remove('hidden');
                elements.winnerModal.focus();
                updateDisplay();
            }

            function updateDisplay() {
                updateStatus();
                updateTimerDisplay();
            }

            function updateStatus() {
                if (gameState.gameOver) {
                    elements.statusMessage.textContent = gameState.winner ?
                        `Game Over - ${gameState.winner.name} wins!` : 'Game Over - Draw!';
                    return;
                }
                if (gameState.isPaused) {
                    elements.statusMessage.textContent = 'Game Paused';
                    return;
                }
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                let status = `${currentPlayer.name}'s Turn`;
                if (gameState.settings.gameMode === 'fixed_turn') {
                    status += ` (${gameState.turnsTaken[gameState.currentPlayerIndex] + 1}/${gameState.settings.turnLimit})`;
                }
                elements.statusMessage.innerHTML = `
                    <span class="inline-block w-5 h-5 rounded-full mr-2"
                          style="background-color: ${currentPlayer.color};"
                          aria-hidden="true"></span>
                    ${status}
                `;
            }

            function updateTimerDisplay() {
                if (gameState.settings.gameMode !== 'timed') {
                    elements.timerDisplay.textContent = '';
                    return;
                }
                const gameMinutes = Math.floor(gameState.timers.remainingGameTime / 60);
                const gameSeconds = gameState.timers.remainingGameTime % 60;
                let display = `Game: ${gameMinutes}:${gameSeconds.toString().padStart(2, '0')}`;
                if (gameState.settings.turnTimeLimit > 0) {
                    display += ` | Turn: ${gameState.timers.remainingTurnTime}s`;
                }
                elements.timerDisplay.textContent = display;
            }

            function updateMoveHistory() {
                const history = gameState.moveHistory.slice(-10);
                elements.historyList.innerHTML = history.map((move, index) => {
                    const moveNumber = gameState.moveHistory.length - history.length + index + 1;
                    const player = gameState.players[move.player];
                    return `<div class="mb-1">
                        <span style="color: ${player.color};">●</span>
                        Move ${moveNumber}: ${player.name} → Column ${move.col + 1}
                    </div>`;
                }).join('');
            }

            // --- Timer Functions ---
            function clearTimers() {
                if (gameState.timers && gameState.timers.gameTimerId) {
                    clearInterval(gameState.timers.gameTimerId);
                    gameState.timers.gameTimerId = null;
                }
                if (gameState.timers && gameState.timers.turnTimerId) {
                    clearInterval(gameState.timers.turnTimerId);
                    gameState.timers.turnTimerId = null;
                }
            }

            function startGameTimer() {
                gameState.timers.gameTimerId = setInterval(() => {
                    if (gameState.isPaused || gameState.gameOver) return;
                    gameState.timers.remainingGameTime--;
                    updateTimerDisplay();
                    if (gameState.timers.remainingGameTime <= 0) {
                        endGame("Time's up! It's a draw!");
                    }
                }, 1000);
            }

            function startTurnTimer() {
                gameState.timers.remainingTurnTime = gameState.settings.turnTimeLimit;
                gameState.timers.turnTimerId = setInterval(() => {
                    if (gameState.isPaused || gameState.gameOver) return;
                    gameState.timers.remainingTurnTime--;
                    updateTimerDisplay();
                    if (gameState.timers.remainingTurnTime <= 0) {
                        clearInterval(gameState.timers.turnTimerId);
                        nextTurn();
                    }
                }, 1000);
            }

            function resetTurnTimer() {
                if (gameState.timers.turnTimerId) {
                    clearInterval(gameState.timers.turnTimerId);
                    gameState.timers.turnTimerId = null;
                }
            }

            // --- AI Functions ---
            function aiMove(difficulty) {
                if (gameState.gameOver) return;
                let col;
                switch (difficulty) {
                    case 'easy':
                        col = getEasyAIMove();
                        break;
                    case 'medium':
                        col = getMediumAIMove();
                        break;
                    case 'hard':
                        col = getHardAIMove();
                        break;
                    default:
                        col = getMediumAIMove();
                }
                if (col !== -1) {
                    makeMove(col);
                }
            }

            function getValidMoves() {
                const validCols = [];
                for (let c = 0; c < gameState.settings.cols; c++) {
                    if (getNextAvailableRow(c) !== -1) {
                        validCols.push(c);
                    }
                }
                return validCols;
            }

            function getEasyAIMove() {
                const validCols = getValidMoves();
                return validCols.length > 0 ?
                    validCols[Math.floor(Math.random() * validCols.length)] : -1;
            }

            function getMediumAIMove() {
                const validCols = getValidMoves();
                const aiId = gameState.players[gameState.currentPlayerIndex].id;

                // Check for winning move
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = aiId;
                    if (checkWin(row, col)) {
                        gameState.board[row][col] = 0;
                        return col;
                    }
                    gameState.board[row][col] = 0;
                }

                // Check for blocking moves
                for (let i = 0; i < gameState.players.length; i++) {
                    if (i === gameState.currentPlayerIndex) continue;
                    const opponentId = gameState.players[i].id;
                    for (const col of validCols) {
                        const row = getNextAvailableRow(col);
                        gameState.board[row][col] = opponentId;
                        if (checkWin(row, col)) {
                            gameState.board[row][col] = 0;
                            return col;
                        }
                        gameState.board[row][col] = 0;
                    }
                }

                // Prefer center columns
                const centerCol = Math.floor(gameState.settings.cols / 2);
                const centerCols = [centerCol];
                if (gameState.settings.cols > 4) {
                    centerCols.push(centerCol - 1, centerCol + 1);
                }
                for (const col of centerCols) {
                    if (validCols.includes(col)) {
                        return col;
                    }
                }
                return validCols[Math.floor(Math.random() * validCols.length)];
            }

            function getHardAIMove() {
                const validCols = getValidMoves();
                if (validCols.length === 0) return -1;

                const aiId = gameState.players[gameState.currentPlayerIndex].id;
                let bestScore = -Infinity;
                let bestCol = validCols[0];

                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = aiId;
                    const score = minimax(4, false, -Infinity, Infinity, gameState.currentPlayerIndex);
                    gameState.board[row][col] = 0;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCol = col;
                    }
                }
                return bestCol;
            }

            function minimax(depth, isMaximizing, alpha, beta, originalAI) {
                if (depth === 0 || isBoardFull() || gameState.gameOver) {
                    return evaluateBoard(originalAI);
                }
                const validCols = getValidMoves();
                const currentPlayerId = gameState.players[gameState.currentPlayerIndex].id;

                if (isMaximizing) {
                    let maxScore = -Infinity;
                    for (const col of validCols) {
                        const row = getNextAvailableRow(col);
                        gameState.board[row][col] = currentPlayerId;
                        if (checkWin(row, col)) {
                            gameState.board[row][col] = 0;
                            return 1000 + depth;
                        }
                        const nextPlayer = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                        const originalPlayer = gameState.currentPlayerIndex;
                        gameState.currentPlayerIndex = nextPlayer;

                        const score = minimax(depth - 1, originalAI === nextPlayer, alpha, beta, originalAI);

                        gameState.currentPlayerIndex = originalPlayer;
                        gameState.board[row][col] = 0;

                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break;
                    }
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    for (const col of validCols) {
                        const row = getNextAvailableRow(col);
                        gameState.board[row][col] = currentPlayerId;
                        if (checkWin(row, col)) {
                            gameState.board[row][col] = 0;
                            return -1000 - depth;
                        }
                        const nextPlayer = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                        const originalPlayer = gameState.currentPlayerIndex;
                        gameState.currentPlayerIndex = nextPlayer;

                        const score = minimax(depth - 1, originalAI === nextPlayer, alpha, beta, originalAI);

                        gameState.currentPlayerIndex = originalPlayer;
                        gameState.board[row][col] = 0;

                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break;
                    }
                    return minScore;
                }
            }

            function evaluateBoard(aiPlayerIndex) {
                const aiId = gameState.players[aiPlayerIndex].id;
                let score = 0;

                // Center column preference
                const centerCol = Math.floor(gameState.settings.cols / 2);
                for (let r = 0; r < gameState.settings.rows; r++) {
                    if (gameState.board[r][centerCol] === aiId) {
                        score += 3;
                    } else if (gameState.board[r][centerCol] !== 0) {
                        score -= 1;
                    }
                }

                // Evaluate all positions
                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        score += evaluatePosition(r, c, aiId);
                    }
                }
                return score;
            }

            function evaluatePosition(row, col, aiId) {
                let score = 0;
                const directions = [
                    [0, 1],
                    [1, 0],
                    [1, 1],
                    [1, -1]
                ];

                for (const [dr, dc] of directions) {
                    if (!gameState.settings.enableDiagonal && dr === 1 && dc !== 0) continue;
                    let aiCount = 0,
                        opponentCount = 0,
                        empty = 0;

                    for (let i = 0; i < gameState.settings.winCondition; i++) {
                        const r = row + i * dr;
                        const c = col + i * dc;
                        if (r >= 0 && r < gameState.settings.rows &&
                            c >= 0 && c < gameState.settings.cols) {
                            if (gameState.board[r][c] === aiId) {
                                aiCount++;
                            } else if (gameState.board[r][c] !== 0) {
                                opponentCount++;
                            } else {
                                empty++;
                            }
                        }
                    }

                    if (aiCount > 0 && opponentCount === 0) {
                        score += Math.pow(10, aiCount);
                    } else if (opponentCount > 0 && aiCount === 0) {
                        score -= Math.pow(10, opponentCount);
                    }
                }
                return score;
            }

            // --- Game Controls ---
            function togglePause() {
                if (gameState.gameOver) return;
                gameState.isPaused = !gameState.isPaused;
                elements.pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';
                if (gameState.isPaused) {
                    gameState.timers.gamePaused = true;
                    gameState.timers.turnPaused = true;
                } else {
                    gameState.timers.gamePaused = false;
                    gameState.timers.turnPaused = false;
                }
                updateDisplay();
            }

            function undoMove() {
                if (gameState.moveHistory.length === 0 || gameState.gameOver) return;
                const lastMove = gameState.moveHistory.pop();
                gameState.board = lastMove.boardState;
                gameState.turnsTaken[lastMove.player]--;
                gameState.currentPlayerIndex = lastMove.player;
                gameState.winningCells = [];
                renderBoard(); // Re-render to reflect undone move
                updateMoveHistory();
                elements.undoBtn.disabled = gameState.moveHistory.length === 0;
                updateDisplay();
            }

            function showHint() {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer.isAI) return;

                document.querySelectorAll('.hint-highlight').forEach(el => {
                    el.classList.remove('hint-highlight');
                });

                const col = getMediumAIMove();
                if (col !== -1) {
                    gameState.lastHintColumn = col;
                    for (let r = 0; r < gameState.settings.rows; r++) {
                        const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${col}']`);
                        if (cell) {
                            cell.classList.add('column-highlight'); // Use class for highlight
                            setTimeout(() => {
                                cell.classList.remove('column-highlight');
                            }, 2000);
                        }
                    }
                }
            }

            function saveGame() {
                if (!gameState.isPaused && !gameState.gameOver) {
                    alert('Please pause the game before saving.');
                    return;
                }
                try {
                    const saveData = {
                        version: SAVE_FILE_VERSION,
                        gameState: gameState,
                        timestamp: new Date().toISOString()
                    };
                    const blob = new Blob([JSON.stringify(saveData, null, 2)], {
                        type: 'application/json'
                    });
                    const now = new Date();
                    const timestamp = now.toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
                    const filename = `connect4_${gameState.settings.gameMode}_${timestamp}.json`;
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                } catch (error) {
                    console.error('Save failed:', error);
                    alert('Failed to save game. Please try again.');
                }
            }

            function loadGame(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const saveData = JSON.parse(e.target.result);
                        if (!saveData.version || !saveData.gameState) {
                            throw new Error('Invalid save file format');
                        }
                        if (saveData.version !== SAVE_FILE_VERSION) {
                            if (!confirm('This save file is from a different version. Loading may cause issues. Continue?')) {
                                return;
                            }
                        }
                        cleanupGame();
                        gameState = saveData.gameState;

                        // Restore UI settings
                        elements.boardRowsInput.value = gameState.settings.rows;
                        elements.boardColsInput.value = gameState.settings.cols;
                        elements.winConditionInput.value = gameState.settings.winCondition;
                        elements.enableDiagonalCheckbox.checked = gameState.settings.enableDiagonal;
                        elements.gameModeSelect.value = gameState.settings.gameMode;
                        elements.timeLimitSelect.value = gameState.settings.timeLimit;
                        elements.turnTimeLimitSelect.value = gameState.settings.turnTimeLimit;
                        elements.turnLimitInput.value = gameState.settings.turnLimit;
                        elements.playerModeSelect.value = gameState.settings.playerMode;

                        updateGameModeOptionsVisibility();
                        updatePlayerInputs();

                        // Restore board color
                        elements.boardVisualLayer.style.backgroundColor = elements.boardColorSelect.value;

                        renderBoard(); // Re-render board with new settings and mask
                        updateMoveHistory();
                        updateDisplay();

                        if (gameState.settings.gameMode === 'timed' && !gameState.gameOver) {
                            if (!gameState.isPaused) {
                                startGameTimer();
                                if (gameState.settings.turnTimeLimit > 0) {
                                    startTurnTimer();
                                }
                            }
                        }
                        elements.pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';
                        elements.undoBtn.disabled = gameState.moveHistory.length === 0;
                        event.target.value = '';
                        alert('Game loaded successfully!');

                    } catch (error) {
                        console.error('Load failed:', error);
                        alert('Failed to load game file. Please check the file and try again.');
                    }
                };
                reader.readAsText(file);
            }

            // --- Initialize Game ---
            init();
        });
    </script>
</body>

</html>