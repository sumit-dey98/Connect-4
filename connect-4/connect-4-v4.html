<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 Advanced - Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for the document and theme variables */
        :root {
            --background-light: #f3f4f6;
            --text-light: #1f2937;
            --board-bg-light: #4b5563;
            --background-dark: #1f2937;
            --text-dark: #f3f4f6;
            --board-bg-dark: #374151;
        }

        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.2s ease, color 0.2s ease;
        }



        /* Dark theme variables */
        .dark {
            --background: var(--background-dark);
            --text: var(--text-dark);
            --board-bg: var(--board-bg-dark);
        }

        /* Light theme variables */
        .light {
            --background: var(--background-light);
            --text: var(--text-light);
            --board-bg: var(--board-bg-light);
        }

        /* The .hole div is no longer used for visual holes, so hide it */
        .hole {
            display: none;
        }

        /* Styling for each cell on the game board (now just interactive areas) */
        .cell {
            position: relative;
            /* Crucial for positioning landed discs inside */
            border-radius: 3px;
            overflow: hidden;
            /* Clips content outside cell boundary */
            /* No background or z-index here, as it's handled by other layers */
        }

        /* Styling for a disc (after landing) */
        .disc {
            width: 90%;
            height: 90%;
            border-radius: 50%;
            /* border: 2px solid rgba(255, 255, 255, 0.6); */
            box-shadow: inset 0 0px 4px rgba(255, 255, 255, 0.4),
                inset 0px 0px 8px rgba(0, 0, 0, 0.2);
            z-index: -1;
        }

        /* Styling for the disc during the falling animation */
        .falling-disc {
            position: absolute;
            pointer-events: none;
            /* transform-origin: center; */
            /* right: 2px; */
            /* border: 2px solid rgba(255, 255, 255, 0.6); */
            /* box-shadow: inset 0 0px 8px rgba(255, 255, 255, 0.5),inset 0px 0px 15px rgba(0, 0, 0, 0.5); */
        }

        /* Highlight for columns on hover */
        .column-highlight {
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        /* Hover effect for column highlight */
        /* .column-highlight:hover {
            background: rgba(255, 255, 255, 0.2);
        } */

        /* Modal backdrop for pop-ups */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        /* Content area for modals */
        .modal-content {
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw;
        }

        /* Styling for the game board container - the main wrapper */
        #game-board-container {
            /* border: 4px solid #2d3748; */

            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            border-radius: 2%;
            aspect-ratio: var(--board-aspect-ratio, 7/6);
        }

        /* Layer for falling discs only */
        #falling-disc-layer {
            /* Renamed from falling-disc-animation-layer */
            position: absolute;
            inset: 0;
            /* Covers the entire parent container */
            overflow: hidden;
            /* Clips discs if they go outside */
            z-index: 0;
            /* Lowest layer, behind the board visual */
        }

        /* Layer for the board visual with holes (the mask will be here) */
        #board-visual-layer {
            position: absolute;
            inset: 0;
            /* Covers the entire parent container */
            z-index: 1;
            /* Above the falling disc layer */
            background-color: var(--board-bg);
            /* The solid board color */

            /* CSS Masking Properties */
            mask-image: none;
            /* Will be set dynamically by JS */
            mask-mode: alpha;
            mask-composite: exclude;
            /* Subtracts new masks from previous */
            -webkit-mask-image: none;
            -webkit-mask-mode: alpha;
            -webkit-mask-composite: exclude;
            /* border: #0000003f 5px solid; */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 15px rgba(0, 0, 0, 0.2);
            border-radius: 2%;
        }

        /* The interactive grid (cells for click events) - no visual background */
        #game-board {
            position: relative;
            /* Positioned relative to #game-board-container */
            inset: 0;
            /* Covers the entire parent container */
            z-index: 2;
            /* Above the board visual layer, for clickability */
            padding: 12px;
            /* p-2 in Tailwind is 0.5rem = 8px; crucial for JS calculations */
            height: 100%;
            display: grid;
            gap: 12px;
            /* border-radius: 15px; */
            /* No background-color or mask here */
        }

        /* Screen reader only text */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus styles for interactive elements */
        .focus-visible:focus {
            background-color: #f0f0f075;
        }



        /* Keyboard navigation focus style */
        .keyboard-focus {
            outline: aliceblue auto 5px;
        }

        .cell.aspect-square.flex.justify-center.items-center {
            border-radius: 50%;
            box-shadow: inset 0px -15px 15px rgba(0, 0, 0, 0.3), 0px 0px 10px #e7e7e793;
            border: 2px solid #e7e7e72f;
        }

        #board-visual-layer {
            position: absolute;
            inset: 0;
            z-index: 1;

        }

        /* Color dropdown styles */
        .color-dropdown {
            position: relative;
            display: inline-block;
        }

        .color-dropdown-button {
            width: 4rem;
            height: 2.5rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-dropdown-content {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1000;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.25rem;
            width: 120px;
        }

        .color-dropdown-content.show {
            display: grid;
        }

        .color-option {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: #374151;
        }

        .color-option.selected {
            border-color: #1f2937;
            border-width: 3px;
        }

        /* Dark theme styles */
        .dark .color-dropdown-content {
            background: #374151;
            border-color: #6b7280;
        }

        .dark .color-option {
            border-color: #6b7280;
        }

        .dark .color-option:hover {
            border-color: #f3f4f6;
        }

        .dark .color-option.selected {
            border-color: #f3f4f6;
        }

        .modal-content,
        aside,
        button,
        select,
        input,
        #game-info {
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .modal-content {
                padding: 1.5rem;
                margin: 1rem;
            }

            #game-board-container {
                max-width: 100%;
                margin: 0 auto;
                box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.15),
                    0 1px 4px rgba(0, 0, 0, 0.1);
            }

            .disc {
                width: 95%;
                height: 95%;
                border: 0.5px solid rgba(0, 0, 0, 0.1);
                box-shadow: inset 0 0px 2px rgba(255, 255, 255, 0.3),
                    inset 0px 0px 4px rgba(0, 0, 0, 0.15);
            }

            .dark .disc {
                border: 0.5px solid rgba(255, 255, 255, 0.1);
                box-shadow: inset 0 0px 2px rgba(255, 255, 255, 0.2),
                    inset 0px 0px 4px rgba(0, 0, 0, 0.3);
            }

            #board-visual-layer {
                box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.15),
                    0 1px 4px rgba(0, 0, 0, 0.1);
            }

            .cell.aspect-square.flex.justify-center.items-center {
                box-shadow: inset 0px -12px 10px rgba(0, 0, 0, 0.3), -2px -2px 8px rgba(231, 231, 231, 0.3), 2px 2px 8px rgba(0, 0, 0, 0.3);
                border: 3px solid rgba(255, 255, 255, 0.3);
            }

            .falling-disc {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2),
                    inset 0 0px 2px rgba(255, 255, 255, 0.15);
            }

            .column-highlight {
                background: rgba(255, 255, 255, 0.15);
                cursor: pointer;
            }

            .dark .column-highlight {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        @media (max-width: 480px) {

            #game-board {
                gap:6px;
                padding: 9px;
            }

            .disc {
                box-shadow: inset 0 0px 1px rgba(255, 255, 255, 0.2),
                    inset 0px 0px 2px rgba(0, 0, 0, 0.1);
            }

            #game-board-container,
            #board-visual-layer {
                box-shadow: inset 0 0 2px rgba(0, 0, 0, 0.1),
                    0 1px 2px rgba(0, 0, 0, 0.08);
            }

            .cell.aspect-square.flex.justify-center.items-center {
                box-shadow: inset 0px -6px 8px rgba(0, 0, 0, 0.3),
                -2px -2px 8px rgba(231, 231, 231, 0.3), 
                2px 2px 8px rgba(0, 0, 0, 0.3);

                border: 1.5px solid rgba(231, 231, 231, 0.1);
            }

            .falling-disc {
                box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15),
                    inset 0 0px 1px rgba(255, 255, 255, 0.1);
            }
        }

        /* High DPI/Retina display adjustments */
        @media (-webkit-min-device-pixel-ratio: 2),
        (min-resolution: 192dpi) {
            .disc {
                /* Slightly increase shadow blur for crisp high-DPI displays */
                box-shadow: inset 0 0px 3px rgba(255, 255, 255, 0.4),
                    inset 0px 0px 6px rgba(0, 0, 0, 0.2);
            }
        }

        /* Reduce shadow complexity for older mobile browsers */
        @supports not (box-shadow: inset 0 0 1px red) {

            .disc,
            #game-board-container,
            #board-visual-layer,
            .cell.aspect-square.flex.justify-center.items-center,
            .falling-disc {
                box-shadow: none;
                border: 1px solid rgba(0, 0, 0, 0.2);
            }

            .dark .disc,
            .dark #game-board-container,
            .dark #board-visual-layer,
            .dark .cell.aspect-square.flex.justify-center.items-center,
            .dark .falling-disc {
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
        }
    </style>
</head>

<body class="light bg-[var(--background)] text-[var(--text)]" role="main">

    <div class="container mx-auto p-4 flex flex-col lg:flex-row gap-8">
        <!-- Game Board and Info -->
        <main class="w-full lg:w-2/3">
            <h1 class="text-4xl font-bold text-center mb-4">Connect</h1>

            <div id="game-info" class="text-center mb-4 h-16 flex flex-col items-center justify-center">
                <p id="status-message" class="text-xl font-medium" aria-live="polite"></p>
                <p id="timer-display" class="text-sm text-gray-600 dark:text-gray-400" aria-live="polite"></p>
            </div>

            <div id="game-board-container" class="mx-auto aspect-[7/6] max-w-full rounded-lg shadow-lg">

                <!-- Layer for falling discs only -->
                <div id="falling-disc-layer" class="absolute inset-0 overflow-hidden"></div>

                <!-- Layer for the board visual with holes (the mask will be here) -->
                <div id="board-visual-layer" class="absolute inset-0"></div>

                <!-- The interactive grid (cells for click events) - no visual background -->
                <div id="game-board" class="h-full" role="grid" aria-label="Connect 4 game board">
                    <!-- Game board cells (now just invisible click targets) will be generated here -->
                </div>
            </div>

            <div id="game-controls" class="flex flex-wrap justify-center gap-4 mt-4">
                <button id="pause-btn"
                    class="px-4 py-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 focus-visible:focus transition-colors"
                    aria-label="Pause game">
                    Pause
                </button>
                <button id="undo-btn"
                    class="px-4 py-2 bg-orange-500 text-white rounded-lg shadow hover:bg-orange-600 focus-visible:focus transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    aria-label="Undo last move" disabled>
                    Undo
                </button>
                <button id="hint-btn"
                    class="px-4 py-2 bg-purple-500 text-white rounded-lg shadow hover:bg-purple-600 focus-visible:focus transition-colors"
                    aria-label="Get hint">
                    Hint
                </button>
                <button id="save-btn"
                    class="px-4 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 focus-visible:focus transition-colors"
                    aria-label="Save current game">
                    Save Game
                </button>
                <label
                    class="px-4 py-2 bg-yellow-500 text-white rounded-lg shadow hover:bg-yellow-600 cursor-pointer focus-within:ring-2 focus-within:ring-yellow-300 transition-colors">
                    Load Game
                    <input type="file" id="load-game-input" class="sr-only" accept=".json" aria-label="Load saved game">
                </label>
            </div>

            <div id="move-history" class="mt-4 text-center">
                <h3 class="text-lg font-semibold mb-2">Move History</h3>
                <div id="history-list" class="text-sm text-gray-600 dark:text-gray-400 max-h-32 overflow-y-auto">
                    <!-- Move history will appear here -->
                </div>
            </div>
        </main>

        <!-- Settings Panel -->
        <aside
            class="w-full lg:w-1/3 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100 p-6 rounded-lg shadow-md">

            <button id="start-game-btn"
                class="w-full px-4 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 focus-visible:focus transition-all transform hover:scale-105 mb-8">
                Start New Game
            </button>

            <details open>
                <summary class="text-2xl font-bold mb-4 border-b pb-2">Game Settings</summary>

                <!-- Theme Settings -->
                <div class="mb-4">
                    <label class="block font-medium mb-2">Theme</label>
                    <div class="flex gap-2">
                        <button id="light-mode-btn"
                            class="flex-1 px-4 py-2 bg-gray-200 text-gray-900 rounded-lg focus-visible:focus transition-colors">Light</button>
                        <button id="dark-mode-btn"
                            class="flex-1 px-4 py-2 bg-gray-700 text-white rounded-lg focus-visible:focus transition-colors">Dark</button>
                    </div>
                </div>
                
                <!-- Board Color -->
                <div class="mb-4">
                    <label for="board-color" class="block font-medium mb-1">Board Color</label>
                    <select id="board-color" class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                        <option value="#1469f4">Blue</option>
                        <option value="#4b5563">Gray</option>
                        <option value="#8b5cf6">Purple</option>
                        <option value="#00bd13">Green</option>
                    </select>
                </div>
                
                <!-- Game Mode -->
                <div class="mb-4">
                    <label for="game-mode" class="block font-medium mb-1">Game Mode</label>
                    <select id="game-mode" class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                        <option value="classic">Classic</option>
                        <option value="timed">Timed</option>
                        <option value="fixed_turn">Fixed Turn</option>
                    </select>
                </div>
                
                <!-- Timed Mode Options -->
                <div id="timed-options" class="hidden mb-4 pl-4 border-l-2 border-blue-300">
                    <label for="time-limit" class="block font-medium mb-1">Game Time Limit</label>
                    <select id="time-limit" class="w-full p-2 rounded bg-white dark:bg-gray-700 border mb-2 focus-visible:focus">
                        <option value="120">2 minutes</option>
                        <option value="300">5 minutes</option>
                        <option value="600">10 minutes</option>
                        <option value="1200">20 minutes</option>
                    </select>
                    <label for="turn-time-limit" class="block font-medium mb-1">Turn Time Limit</label>
                    <select id="turn-time-limit" class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                        <option value="0">No Limit</option>
                        <option value="10">10 seconds</option>
                        <option value="15">15 seconds</option>
                        <option value="30">30 seconds</option>
                    </select>
                </div>
                
                <!-- Fixed Turn Options -->
                <div id="fixed-turn-options" class="hidden mb-4 pl-4 border-l-2 border-green-300">
                    <label for="turn-limit" class="block font-medium mb-1">Turns per Player</label>
                    <input type="number" id="turn-limit" value="15" min="5" max="50"
                        class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                </div>
                
                <!-- Player Setup -->
                <div class="mb-4">
                    <label for="player-mode" class="block font-medium mb-1">Players</label>
                    <select id="player-mode" class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                        <option value="vs_com">vs Computer</option>
                        <option value="2_player">2 Players</option>
                        <option value="3_player">3 Players</option>
                        <option value="4_player">4 Players</option>
                    </select>
                </div>
                
                <!-- AI Settings -->
                <div id="ai-settings-container" class="mb-4 pl-4 border-l-2 border-red-300">
                    <!-- AI difficulty settings will be generated here -->
                </div>
                
                <!-- Player Names -->
                <div id="player-names-container" class="mb-4 space-y-2">
                    <label class="block font-medium mb-2">Customize Players Details</label>
                    <!-- Player name inputs will be generated here -->
                </div>
                
                <!-- Player Colors -->
                <div id="player-colors-container" class="mb-4 space-y-2">
                    <!-- Player color inputs will be generated here -->
                </div>
                
                
                
                <!-- Board Size -->
                <div class="mb-4">
                    <label class="block font-medium mb-1">Board Size</label>
                    <div class="flex gap-2 items-center">
                        <input type="number" id="board-cols" value="7" min="4" max="15"
                            class="w-1/2 p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus"
                            aria-label="Number of columns">
                        <span>×</span>
                        <input type="number" id="board-rows" value="6" min="4" max="15"
                            class="w-1/2 p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus" aria-label="Number of rows">
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Columns × Rows (4-15 each)</p>
                </div>
                
                <!-- Win Condition -->
                <div class="mb-4">
                    <label for="win-condition" class="block font-medium mb-1">Discs to Win</label>
                    <input type="number" id="win-condition" value="4" min="3" max="8"
                        class="w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus">
                    <p class="text-xs text-gray-500 mt-1">Must be ≤ smallest board dimension</p>
                </div>
                
                <!-- Diagonal Match -->
                <div class="mb-6 flex items-center gap-2">
                    <input type="checkbox" id="enable-diagonal" class="h-5 w-5 rounded focus-visible:focus" checked>
                    <label for="enable-diagonal">Enable Diagonal Matches</label>
                </div>
                
                <!-- Audio Settings -->
                <div class="mb-4">
                    <div class="flex items-center gap-2 mb-2">
                        <input type="checkbox" id="enable-sound" class="h-5 w-5 rounded focus-visible:focus" checked>
                        <label for="enable-sound" class="font-medium">Enable Sound Effects</label>
                    </div>
                </div>
            </details>
            

            

            
        </aside>
    </div>

    <!-- Modal for Winner/Draw -->
    <div id="winner-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true"
        aria-labelledby="winner-message">
        <div class="modal-content bg-[var(--background)] text-[var(--text)] text-center">
            <h3 id="winner-message" class="text-3xl font-bold mb-4"></h3>
            <div class="flex gap-4 justify-center">
                <button id="play-again-btn"
                    class="px-6 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 focus-visible:focus transition-colors">
                    Play Again
                </button>
                <button id="close-modal-btn"
                    class="px-6 py-2 bg-gray-500 text-white rounded-lg shadow hover:bg-gray-600 focus-visible:focus transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Audio Elements -->
    <div id="audio-container" style="display: none;">
        <audio id="disc-drop-sound" preload="auto">
            <source src="sounds/disc-drop.mp3" type="audio/mpeg">
            <source src="sounds/disc-drop.wav" type="audio/wav">
        </audio>
        <audio id="win-sound" preload="auto">
            <source src="sounds/win.mp3" type="audio/mpeg">
            <source src="sounds/win.wav" type="audio/wav">
        </audio>
        <audio id="computer-win-sound" preload="auto">
            <source src="sounds/computer-win.mp3" type="audio/mpeg">
            <source src="sounds/computer-win.wav" type="audio/wav">
        </audio>
        <audio id="button-click-sound" preload="auto">
            <source src="sounds/button-click.mp3" type="audio/mpeg">
            <source src="sounds/button-click.wav" type="audio/wav">
        </audio>
        <audio id="column-hover-sound" preload="auto">
            <source src="sounds/hover.mp3" type="audio/mpeg">
            <source src="sounds/hover.wav" type="audio/wav">
        </audio>
        <audio id="error-sound" preload="auto">
            <source src="sounds/error.mp3" type="audio/mpeg">
            <source src="sounds/error.wav" type="audio/wav">
        </audio>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants ---
            const SAVE_FILE_VERSION = "1.0";
            const DEFAULT_PLAYER_COLORS = ['#ff0000', '#00ff00', '#ffff00', '#0000ff', '#ff00ff', '#00ffff', '#ffa500', '#ffffff', '#000000'];
            const ANIMATION_DURATION = 500; // milliseconds

            // --- DOM Elements ---
            const elements = {
                gameBoard: document.getElementById('game-board'), // Now the interactive grid
                statusMessage: document.getElementById('status-message'),
                timerDisplay: document.getElementById('timer-display'),
                boardContainer: document.getElementById('game-board-container'),
                winnerModal: document.getElementById('winner-modal'),
                winnerMessage: document.getElementById('winner-message'),
                historyList: document.getElementById('history-list'),
                fallingDiscLayer: document.getElementById('falling-disc-layer'), // Renamed
                boardVisualLayer: document.getElementById('board-visual-layer'), // Reference to the board visual layer
                // discLayer: document.getElementById('disc-layer'), // No longer needed for landed discs

                // Settings
                lightModeBtn: document.getElementById('light-mode-btn'),
                darkModeBtn: document.getElementById('dark-mode-btn'),
                boardColorSelect: document.getElementById('board-color'),
                gameModeSelect: document.getElementById('game-mode'),
                timedOptions: document.getElementById('timed-options'),
                timeLimitSelect: document.getElementById('time-limit'),
                turnTimeLimitSelect: document.getElementById('turn-time-limit'),
                fixedTurnOptions: document.getElementById('fixed-turn-options'),
                turnLimitInput: document.getElementById('turn-limit'),
                playerModeSelect: document.getElementById('player-mode'),
                aiSettingsContainer: document.getElementById('ai-settings-container'),
                playerNamesContainer: document.getElementById('player-names-container'),
                playerColorsContainer: document.getElementById('player-colors-container'),
                boardColsInput: document.getElementById('board-cols'),
                boardRowsInput: document.getElementById('board-rows'),
                winConditionInput: document.getElementById('win-condition'),
                enableDiagonalCheckbox: document.getElementById('enable-diagonal'),
                startGameBtn: document.getElementById('start-game-btn'),

                // Controls
                pauseBtn: document.getElementById('pause-btn'),
                undoBtn: document.getElementById('undo-btn'),
                hintBtn: document.getElementById('hint-btn'),
                saveBtn: document.getElementById('save-btn'),
                loadGameInput: document.getElementById('load-game-input'),
                playAgainBtn: document.getElementById('play-again-btn'),
                closeModalBtn: document.getElementById('close-modal-btn'),

                // Audio elements
                enableSoundCheckbox: document.getElementById('enable-sound'),

                // Audio files
                discDropSound: document.getElementById('disc-drop-sound'),
                winSound: document.getElementById('win-sound'),
                computerWinSound: document.getElementById('computer-win-sound'),
                buttonClickSound: document.getElementById('button-click-sound'),
                columnHoverSound: document.getElementById('column-hover-sound'),
                errorSound: document.getElementById('error-sound')
            };

            // --- Game State ---
            let gameState = {};
            let currentFocusedColumn = 0;

            function getDefaultGameState() {
                return {
                    version: SAVE_FILE_VERSION,
                    board: [],
                    players: [],
                    currentPlayerIndex: 0,
                    gameOver: false,
                    isPaused: false,
                    winner: null,
                    winningCells: [],
                    moveHistory: [],
                    lastHintColumn: -1,
                    isInputEnabled: true,

                    settings: {
                        rows: 6,
                        cols: 7,
                        winCondition: 4,
                        enableDiagonal: true,
                        gameMode: 'classic',
                        timeLimit: 120,
                        turnTimeLimit: 0,
                        turnLimit: 15,
                        playerMode: 'vs_com',
                    },

                    timers: {
                        gameTimerId: null,
                        turnTimerId: null,
                        remainingGameTime: 120,
                        remainingTurnTime: 0,
                        gamePaused: false,
                        turnPaused: false,
                    },

                    turnsTaken: [],
                };
            }

            // --- Utility Functions ---
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            function validateSettings() {
                const rows = parseInt(elements.boardRowsInput.value);
                const cols = parseInt(elements.boardColsInput.value);
                const winCondition = parseInt(elements.winConditionInput.value);

                if (rows < 4 || rows > 15 || cols < 4 || cols > 15) {
                    alert('Board dimensions must be between 4 and 15');
                    return false;
                }

                if (winCondition < 3 || winCondition > Math.min(rows, cols)) {
                    alert(`Win condition must be between 3 and ${Math.min(rows, cols)} (the smallest board dimension)`);
                    return false;
                }
                return true;
            }

            function moveColumnFocus(direction) {
                currentFocusedColumn += direction;
                if (currentFocusedColumn < 0) currentFocusedColumn = gameState.settings.cols - 1;
                if (currentFocusedColumn >= gameState.settings.cols) currentFocusedColumn = 0;
                updateColumnHighlight();
            }

            function updateColumnHighlight() {
                document.querySelectorAll('.keyboard-focus').forEach(el => {
                    el.classList.remove('keyboard-focus');
                });
                for (let r = 0; r < gameState.settings.rows; r++) {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${currentFocusedColumn}']`);
                    if (cell) {
                        cell.classList.add('keyboard-focus');
                    }
                }
            }

            function getUniqueColors() {
                const playerCount = getPlayerCount();
                const colors = [];
                const usedColors = new Set();

                for (let i = 0; i < playerCount; i++) {
                    const input = document.getElementById(`player-${i + 1}-color`);
                    let color = input ? input.value : DEFAULT_PLAYER_COLORS[i];
                    let counter = 0;
                    while (usedColors.has(color) && counter < 10) {
                        const hue = Math.floor(Math.random() * 360);
                        color = `hsl(${hue}, 70%, 50%)`;
                        counter++;
                    }
                    if (counter >= 10) {
                        color = DEFAULT_PLAYER_COLORS[i % DEFAULT_PLAYER_COLORS.length];
                    }
                    colors.push(color);
                    usedColors.add(color);
                }
                return colors;
            }

            // --- Initialization ---
            function init() {
                gameState = getDefaultGameState();
                updatePlayerInputs();
                setupEventListeners();
                updateAudioSettings();
                startGame();
            }

            function setupEventListeners() {
                // Theme
                elements.lightModeBtn.addEventListener('click', () => {
                    document.body.className = 'light bg-[var(--background)] text-[var(--text)]';
                });
                elements.darkModeBtn.addEventListener('click', () => {
                    document.body.className = 'dark bg-[var(--background)] text-[var(--text)]';
                });

                // Settings
                elements.boardColorSelect.addEventListener('change', (e) => {
                    // Board background is now on #board-visual-layer
                    elements.boardVisualLayer.style.backgroundColor = e.target.value;
                });
                elements.gameModeSelect.addEventListener('change', updateGameModeOptionsVisibility);
                elements.playerModeSelect.addEventListener('change', updatePlayerInputs);
                elements.startGameBtn.addEventListener('click', startGame);

                // Validation
                const debouncedValidation = debounce(() => {
                    validateInputs();
                }, 300);
                [elements.boardRowsInput, elements.boardColsInput, elements.winConditionInput].forEach(input => {
                    input.addEventListener('input', debouncedValidation);
                });

                // Controls
                elements.pauseBtn.addEventListener('click', togglePause);
                elements.undoBtn.addEventListener('click', undoMove);
                elements.hintBtn.addEventListener('click', showHint);
                elements.saveBtn.addEventListener('click', saveGame);
                elements.loadGameInput.addEventListener('change', loadGame);

                // Modal
                elements.playAgainBtn.addEventListener('click', () => {
                    hideModal();
                    startGame();
                });
                elements.closeModalBtn.addEventListener('click', () => {
                    hideModal();
                });

                // Keyboard support
                document.addEventListener('keydown', handleKeyboard);

                // Add resize handler with debouncing to avoid excessive recalculations
                const debouncedResize = debounce(() => {
                    if (gameState.board && gameState.board.length > 0) {
                        // Clear any falling discs to prevent positioning issues
                        elements.fallingDiscLayer.innerHTML = '';
                        renderBoard();
                    }
                }, 250);

                // Prevent accidental page refresh
                window.addEventListener('beforeunload', (e) => {
                    if (!gameState.gameOver && gameState.moveHistory.length > 0) {
                        e.preventDefault();
                        e.returnValue = '';
                    }
                });
                window.addEventListener('resize', debouncedResize);

                // Close color dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.color-dropdown')) {
                        document.querySelectorAll('.color-dropdown-content').forEach(content => {
                            content.classList.remove('show');
                        });
                    }
                });

                // Audio settings
                elements.enableSoundCheckbox.addEventListener('change', updateAudioSettings);
                // elements.volumeSlider.addEventListener('input', updateAudioSettings);

                // Button sound effects
                const buttonsWithSound = [
                    elements.startGameBtn, elements.pauseBtn, elements.undoBtn,
                    elements.hintBtn, elements.saveBtn, elements.playAgainBtn,
                    elements.closeModalBtn, elements.lightModeBtn, elements.darkModeBtn
                ];

                buttonsWithSound.forEach(button => {
                    if (button) {
                        button.addEventListener('click', () => {
                            playSound(elements.buttonClickSound, 0.3);
                        });
                    }
                });
            }

            function handleKeyboard(e) {
                // Don't handle keyboard events if user is interacting with form elements
                const activeElement = document.activeElement;
                const isFormElement = activeElement && (
                    activeElement.tagName === 'INPUT' ||
                    activeElement.tagName === 'SELECT' ||
                    activeElement.tagName === 'BUTTON' ||
                    activeElement.hasAttribute('contenteditable') ||
                    activeElement.closest('.color-dropdown') ||
                    activeElement.closest('aside') // Settings panel
                );

                // Handle spacebar (pause/resume) but not when interacting with form elements
                if (e.key === ' ') {
                    if (!isFormElement) {
                        e.preventDefault();
                        togglePause();
                    }
                    return;
                }

                // If game is over, paused, input disabled, or user is in form elements, prevent other actions
                if (gameState.gameOver || gameState.isPaused || !gameState.isInputEnabled || isFormElement) return;

                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return;

                if (e.key >= '1' && e.key <= '9') {
                    const col = parseInt(e.key) - 1;
                    if (col < gameState.settings.cols) makeMove(col);
                } else if (e.key === 'h' || e.key === 'H') {
                    showHint();
                } else if (e.key === 'u' || e.key === 'U') {
                    undoMove();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    moveColumnFocus(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    moveColumnFocus(1);
                } else if (e.key === 'ArrowDown' || e.key === 'Enter') {
                    e.preventDefault();
                    makeMove(currentFocusedColumn);
                }
            }

            function updateGameModeOptionsVisibility() {
                const mode = elements.gameModeSelect.value;
                elements.timedOptions.classList.toggle('hidden', mode !== 'timed');
                elements.fixedTurnOptions.classList.toggle('hidden', mode !== 'fixed_turn');
            }

            function updatePlayerInputs() {
                // Update player color and name inputs
                elements.playerColorsContainer.innerHTML = '';
                const playerCount = getPlayerCount();
                for (let i = 0; i < playerCount; i++) {
                    const playerType = getPlayerType(i);
                    const defaultName = playerType === 'Computer' ? 'Computer' : `Player ${i + 1}`;

                    // Combined label for both inputs
                    const label = document.createElement('label');
                    label.className = 'block font-medium mb-1';
                    label.textContent = playerType;

                    // Container for color and name inputs (flex row)
                    const inputContainer = document.createElement('div');
                    inputContainer.className = 'flex gap-2 mb-3';

                    // Color input dropdown
                    const colorDropdown = document.createElement('div');
                    colorDropdown.className = 'color-dropdown';
                    colorDropdown.id = `player-${i + 1}-color-dropdown`;

                    const currentColor = gameState.players && gameState.players[i] ?
                        gameState.players[i].color : DEFAULT_PLAYER_COLORS[i];

                    // Dropdown button
                    const dropdownButton = document.createElement('div');
                    dropdownButton.className = 'color-dropdown-button';
                    dropdownButton.style.backgroundColor = currentColor;
                    dropdownButton.setAttribute('tabindex', '0');
                    dropdownButton.setAttribute('role', 'button');
                    dropdownButton.setAttribute('aria-label', `Select color for ${getPlayerType(i)}`);

                    // Dropdown content
                    const dropdownContent = document.createElement('div');
                    dropdownContent.className = 'color-dropdown-content';

                    // Create color options
                    DEFAULT_PLAYER_COLORS.forEach(color => {
                        const colorOption = document.createElement('div');
                        colorOption.className = 'color-option';
                        colorOption.style.backgroundColor = color;
                        if (color === currentColor) {
                            colorOption.classList.add('selected');
                        }

                        colorOption.addEventListener('click', () => {
                            // Update button color
                            dropdownButton.style.backgroundColor = color;

                            // Update selected state
                            dropdownContent.querySelectorAll('.color-option').forEach(opt =>
                                opt.classList.remove('selected'));
                            colorOption.classList.add('selected');

                            // Update game state
                            if (gameState.players && gameState.players[i]) {
                                gameState.players[i].color = color;
                                renderBoard();
                                updateDisplay();
                                updateMoveHistory();
                            }

                            // Hide dropdown
                            dropdownContent.classList.remove('show');
                        });

                        dropdownContent.appendChild(colorOption);
                    });

                    // Toggle dropdown on button click
                    dropdownButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Hide other dropdowns
                        document.querySelectorAll('.color-dropdown-content').forEach(content => {
                            if (content !== dropdownContent) {
                                content.classList.remove('show');
                            }
                        });
                        dropdownContent.classList.toggle('show');
                    });

                    // Keyboard support
                    dropdownButton.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            dropdownButton.click();
                        }
                    });

                    colorDropdown.appendChild(dropdownButton);
                    colorDropdown.appendChild(dropdownContent);

                    // Name input
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.id = `player-${i + 1}-name`;
                    nameInput.className = 'flex-1 p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus';
                    nameInput.value = gameState.players && gameState.players[i] ?
                        gameState.players[i].name : defaultName;
                    nameInput.placeholder = defaultName;

                    // Add real-time color change functionality
                    colorDropdown.addEventListener('change', (e) => {
                        if (gameState.players && gameState.players[i]) {
                            gameState.players[i].color = e.target.value;
                            renderBoard();
                            updateDisplay();
                            updateMoveHistory();
                        }
                    });

                    // Add real-time name change functionality
                    nameInput.addEventListener('input', (e) => {
                        if (gameState.players && gameState.players[i]) {
                            gameState.players[i].name = e.target.value || defaultName;
                            updateDisplay();
                            updateMoveHistory();
                        }
                    });

                    // Append inputs to container
                    inputContainer.appendChild(colorDropdown);
                    inputContainer.appendChild(nameInput);

                    // Append to main container
                    // elements.playerColorsContainer.appendChild(label);
                    elements.playerColorsContainer.appendChild(inputContainer);
                }

                // Update AI settings
                updateAISettings();
            }

            function updateAISettings() {
                elements.aiSettingsContainer.innerHTML = '';
                if (elements.playerModeSelect.value === 'vs_com') {
                    elements.aiSettingsContainer.classList.remove('hidden');
                    const label = document.createElement('label');
                    label.className = 'block font-medium mb-1';
                    label.textContent = 'AI Difficulty';
                    const select = document.createElement('select');
                    select.id = 'ai-difficulty';
                    select.className = 'w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus';
                    ['easy', 'medium', 'hard'].forEach(difficulty => {
                        const option = document.createElement('option');
                        option.value = difficulty;
                        option.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                        select.appendChild(option);
                    });
                    elements.aiSettingsContainer.appendChild(label);
                    elements.aiSettingsContainer.appendChild(select);
                } else {
                    elements.aiSettingsContainer.classList.add('hidden');
                }
            }

            function getPlayerCount() {
                const mode = elements.playerModeSelect.value;
                switch (mode) {
                    case 'vs_com':
                    case '2_player':
                        return 2;
                    case '3_player':
                        return 3;
                    case '4_player':
                        return 4;
                    default:
                        return 2;
                }
            }

            function getPlayerType(index) {
                if (elements.playerModeSelect.value === 'vs_com' && index === 1) {
                    return 'Computer';
                }
                return `Player ${index + 1}`;
            }

            function validateInputs() {
                const rows = parseInt(elements.boardRowsInput.value);
                const cols = parseInt(elements.boardColsInput.value);
                const winCondition = parseInt(elements.winConditionInput.value);
                if (winCondition > Math.min(rows, cols)) {
                    elements.winConditionInput.value = Math.min(rows, cols);
                }
            }

            // --- Audio Functions ---
            function playSound(audioElement, volume = null) {
                if (!elements.enableSoundCheckbox.checked) return;

                try {
                    audioElement.currentTime = 0;

                    // Use the provided volume or default to full volume
                    const volumeLevel = volume !== null ? volume : 1.0;
                    audioElement.volume = Math.max(0, Math.min(1, volumeLevel));

                    const playPromise = audioElement.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log('Audio play failed:', error);
                        });
                    }
                } catch (error) {
                    console.log('Audio error:', error);
                }
            }

            function updateAudioSettings() {
                const soundEnabled = elements.enableSoundCheckbox.checked;

                // Update all audio elements volume - explicitly target each one
                const volume = soundEnabled ? 1.0 : 0;

                // Set volume for each audio element directly
                if (elements.discDropSound) elements.discDropSound.volume = volume;
                if (elements.winSound) elements.winSound.volume = volume;
                if (elements.computerWinSound) elements.computerWinSound.volume = volume;
                if (elements.buttonClickSound) elements.buttonClickSound.volume = volume;
                if (elements.columnHoverSound) elements.columnHoverSound.volume = volume;
                if (elements.errorSound) elements.errorSound.volume = volume;
            }

            // --- Game Logic ---
            function startGame() {
                if (!validateSettings()) return;
                cleanupGame();
                gameState = getDefaultGameState();

                // Apply settings
                gameState.settings.rows = parseInt(elements.boardRowsInput.value);
                gameState.settings.cols = parseInt(elements.boardColsInput.value);
                gameState.settings.winCondition = parseInt(elements.winConditionInput.value);
                gameState.settings.enableDiagonal = elements.enableDiagonalCheckbox.checked;
                gameState.settings.gameMode = elements.gameModeSelect.value;
                gameState.settings.timeLimit = parseInt(elements.timeLimitSelect.value);
                gameState.settings.turnTimeLimit = parseInt(elements.turnTimeLimitSelect.value);
                gameState.settings.turnLimit = parseInt(elements.turnLimitInput.value);
                gameState.settings.playerMode = elements.playerModeSelect.value;

                // Initialize players
                const playerCount = getPlayerCount();
                const colors = getUniqueColors();
                gameState.players = [];
                gameState.turnsTaken = [];
                for (let i = 0; i < playerCount; i++) {
                    const isAI = elements.playerModeSelect.value === 'vs_com' && i === 1;

                    // Get custom name from input
                    const nameInput = document.getElementById(`player-${i + 1}-name`);
                    const playerName = nameInput ? nameInput.value.trim() || (isAI ? 'Computer' : `Player ${i + 1}`) : (isAI ? 'Computer' : `Player ${i + 1}`);

                    gameState.players.push({
                        id: i + 1,
                        name: playerName,
                        color: colors[i],
                        isAI: isAI,
                        difficulty: isAI ? document.getElementById('ai-difficulty')?.value || 'medium' : null,
                    });
                    gameState.turnsTaken.push(0);
                }


                // Initialize board
                gameState.board = Array(gameState.settings.rows).fill(null).map(() =>
                    Array(gameState.settings.cols).fill(0)
                );

                // Set initial board color on the visual layer
                elements.boardVisualLayer.style.backgroundColor = elements.boardColorSelect.value;

                // Setup timers
                if (gameState.settings.gameMode === 'timed') {
                    gameState.timers.remainingGameTime = gameState.settings.timeLimit;
                    gameState.timers.remainingTurnTime = gameState.settings.turnTimeLimit;
                }

                renderBoard(); // Call renderBoard after all settings are applied
                updateDisplay();
                elements.winnerModal.classList.add('hidden');
                elements.undoBtn.disabled = true;
                elements.historyList.innerHTML = '';

                if (gameState.settings.gameMode === 'timed') {
                    startGameTimer();
                }
                // nextTurn();
                currentFocusedColumn = Math.floor(gameState.settings.cols / 2);
                updateColumnHighlight();

                // Ensure listeners are set up for dynamic color changes
                // setupPlayerColorListeners();

                // LOGIC TO HANDLE INITIAL PLAYER'S TURN (especially if AI)
                const initialPlayer = gameState.players[gameState.currentPlayerIndex]; // Should be Player 1 (index 0)
                if (initialPlayer && initialPlayer.isAI) {
                    setInteractionState(false); // Disable input for AI's turn
                    setTimeout(() => aiMove(initialPlayer.difficulty), 1000); // Trigger AI move after a delay
                } else {
                    setInteractionState(true); // Enable input for human Player 1
                }
            }


            function cleanupGame() {
                clearTimers();
                // Clear any existing falling discs
                if (elements.fallingDiscLayer) {
                    elements.fallingDiscLayer.innerHTML = '';
                }
                // Reset timer states
                if (gameState && gameState.timers) {
                    gameState.timers.gamePaused = false;
                    gameState.timers.turnPaused = false;
                }
            }

            function renderBoard() {
                // Set dynamic aspect ratio
                const aspectRatio = `${gameState.settings.cols}/${gameState.settings.rows}`;
                elements.boardContainer.style.setProperty('--board-aspect-ratio', aspectRatio);
                elements.gameBoard.innerHTML = ''; // Clear interactive cells
                // No longer clearing discLayer, as discs are children of cells now

                elements.gameBoard.style.gridTemplateColumns = `repeat(${gameState.settings.cols}, 1fr)`;
                elements.gameBoard.style.gridTemplateRows = `repeat(${gameState.settings.rows}, 1fr)`;

                // Get computed styles for accurate measurements from the interactive grid
                const boardComputedStyle = window.getComputedStyle(elements.gameBoard);
                const boardPaddingLeft = parseFloat(boardComputedStyle.paddingLeft);
                const boardPaddingTop = parseFloat(boardComputedStyle.paddingTop);
                let gap = 12;
                if (window.innerWidth < 576) {
                    gap = 6;
                }

                // Calculate effective board content dimensions
                const boardContentWidth = elements.gameBoard.clientWidth - boardPaddingLeft - parseFloat(boardComputedStyle.paddingRight);
                const boardContentHeight = elements.gameBoard.clientHeight - boardPaddingTop - parseFloat(boardComputedStyle.paddingBottom);

                const cellWidth = (boardContentWidth - (gameState.settings.cols - 1) * gap) / gameState.settings.cols;
                const cellHeight = (boardContentHeight - (gameState.settings.rows - 1) * gap) / gameState.settings.rows;

                const discDiameter = cellWidth * 0.9; // Diameter of the disc
                const holeRadius = discDiameter / 2; // Radius of the hole

                const maskGradients = [];
                // Start with a solid black background for the mask. This is the base that will be "cut out".
                maskGradients.push('linear-gradient(black, black)');

                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        // Calculate center of each hole relative to #game-board (which is also the coordinate system for boardVisualLayer)
                        const xCenter = boardPaddingLeft + c * (cellWidth + gap) + cellWidth / 2;
                        const yCenter = boardPaddingTop + r * (cellHeight + gap) + cellHeight / 2;

                        // For 'exclude', we want to subtract an opaque circle (black) from the base.
                        // So, the gradient should be black inside the hole, and transparent outside.
                        // Use hard stops for sharp edges.
                        maskGradients.push(`radial-gradient(circle ${holeRadius}px at ${xCenter}px ${yCenter}px, black ${holeRadius * 0.95}px, transparent ${holeRadius * 1}px)`);

                        // Create interactive cell (no visual, just for clicks/hover)
                        const cell = document.createElement('div');
                        cell.className = 'cell aspect-square flex justify-center items-center';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `Row ${r + 1}, Column ${c + 1}`);

                        // Add click/hover listeners to top row cells
                        if (r === 0) {
                            cell.addEventListener('click', () => handleCellClick(c));
                            cell.addEventListener('mouseenter', () => highlightColumn(c, true));
                            cell.addEventListener('mouseleave', () => highlightColumn(c, false));
                            cell.tabIndex = 0;
                            cell.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter' || e.key === ' ') {
                                    e.preventDefault();
                                    handleCellClick(c);
                                }
                            });
                        }
                        elements.gameBoard.appendChild(cell);

                        // If a disc exists, create it and append to the cell
                        const playerOwner = gameState.board[r][c];
                        if (playerOwner > 0) {
                            const disc = document.createElement('div');
                            disc.className = 'disc';
                            disc.style.backgroundColor = gameState.players[playerOwner - 1].color;
                            disc.setAttribute('aria-label', `${gameState.players[playerOwner - 1].name} disc`);
                            cell.appendChild(disc);
                        }
                    }
                }

                // Apply the mask after the container has resized
                requestAnimationFrame(() => {
                    const maskValue = maskGradients.join(', ');
                    elements.boardVisualLayer.style.maskImage = maskValue;
                    elements.boardVisualLayer.style.webkitMaskImage = maskValue;
                });

                highlightWinningCells();
            }

            function highlightColumn(col, highlight) {
                if (gameState.gameOver || gameState.isPaused) return; // No highlight if game is over or paused
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return; // No highlight during AI turn

                for (let r = 0; r < gameState.settings.rows; r++) {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${col}']`);
                    if (cell) {
                        if (highlight && getNextAvailableRow(col) !== -1) {
                            cell.classList.add('column-highlight'); // Add highlight if column is valid for a move
                        } else {
                            cell.classList.remove('column-highlight'); // Remove highlight
                        }
                    }
                }

                // Play hover sound if highlighting and not already played recently
                if (highlight && getNextAvailableRow(col) !== -1) {
                    const cell = elements.gameBoard.querySelector(`[data-row='0'][data-col='${col}']`); // Get top cell for sound
                    if (cell && !cell.dataset.hoverSoundPlayed) {
                        playSound(elements.columnHoverSound, 0.2);
                        cell.dataset.hoverSoundPlayed = 'true';
                        // Prevent sound from playing too frequently
                        setTimeout(() => {
                            delete cell.dataset.hoverSoundPlayed;
                        }, 200);
                    }
                }
            }

            function highlightWinningCells() {
                gameState.winningCells.forEach(([r, c]) => {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${c}']`);
                    const disc = cell?.querySelector('.disc'); // Find the disc within the cell
                    if (disc) {
                        disc.classList.add('winning-disc');
                    }
                });
            }

            function handleCellClick(col) {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return;
                makeMove(col);
            }

            function makeMove(col) {
                if (gameState.gameOver) return;
                const row = getNextAvailableRow(col);
                if (row === -1) {
                    playSound(elements.errorSound, 0.4);
                    return;
                }

                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                setInteractionState(false);

                gameState.moveHistory.push({
                    player: gameState.currentPlayerIndex,
                    col: col,
                    row: row,
                    boardState: gameState.board.map(row => [...row])
                });

                animateDiscDrop(col, row, currentPlayer.color, () => {
                    gameState.board[row][col] = currentPlayer.id;
                    updateMoveHistory();
                    elements.undoBtn.disabled = false;

                    const winner = checkWin(row, col);
                    if (winner) {
                        endGame(`${winner.name} wins!`, winner);
                        return;
                    }

                    if (isBoardFull()) {
                        endGame("It's a draw!");
                        return;
                    }

                    if (gameState.settings.gameMode === 'fixed_turn' &&
                        (gameState.turnsTaken[gameState.currentPlayerIndex] + 1) >= gameState.settings.turnLimit) {

                        // Check if this was the last player's last turn
                        let allPlayersFinished = true;
                        for (let i = 0; i < gameState.players.length; i++) {
                            const turnsForPlayer = i === gameState.currentPlayerIndex ?
                                gameState.turnsTaken[i] + 1 : gameState.turnsTaken[i];
                            if (turnsForPlayer < gameState.settings.turnLimit) {
                                allPlayersFinished = false;
                                break;
                            }
                        }

                        if (allPlayersFinished) {
                            const result = determineFixedTurnWinner();
                            endGame(result.message, result.winner);
                            return;
                        }
                    }

                    nextTurn();
                });
            }

            function animateDiscDrop(col, targetRow, color, callback) {
                // Get the falling disc layer's dimensions instead of gameBoard
                const fallingLayerRect = elements.fallingDiscLayer.getBoundingClientRect();
                const gameBoardRect = elements.gameBoard.getBoundingClientRect();
                const offsetLeft = gameBoardRect.left - fallingLayerRect.left;

                // Get board's computed styles for accurate measurements
                const boardComputedStyle = window.getComputedStyle(elements.gameBoard);
                const boardPaddingLeft = parseFloat(boardComputedStyle.paddingLeft);
                const boardPaddingRight = parseFloat(boardComputedStyle.paddingRight);
                let gap = 12; 
                if (window.innerWidth < 576) {
                    gap = 6;
                }

                // Calculate effective board content width
                const boardContentWidth = elements.gameBoard.clientWidth - boardPaddingLeft - boardPaddingRight;
                // Calculate individual cell width
                const cellWidth = (boardContentWidth - (gameState.settings.cols - 1) * gap) / gameState.settings.cols;

                // Calculate disc's horizontal center relative to board's content area
                const discLeft = offsetLeft + boardPaddingLeft + col * (cellWidth + gap) + cellWidth / 2;
                // Calculate disc size (90% of cell)
                const discSize = cellWidth * 0.9;

                // Create falling disc element
                const fallingDisc = document.createElement('div');
                fallingDisc.className = 'falling-disc disc';
                fallingDisc.style.backgroundColor = color;
                fallingDisc.style.width = `${discSize}px`;
                fallingDisc.style.height = `${discSize}px`;
                fallingDisc.style.willChange = 'transform'; // GPU optimization

                // Set disc's initial position (above board, horizontally centered)
                fallingDisc.style.left = `${discLeft}px`;
                fallingDisc.style.top = '0px'; // Start at top of container
                fallingDisc.style.transform = `translate(-50%, -${discSize * 2}px)`; // Move above board using transform

                // IMPORTANT: Append to the falling disc layer
                elements.fallingDiscLayer.appendChild(fallingDisc);

                // Calculate the offset between the falling layer and game board
                const offsetTop = gameBoardRect.top - fallingLayerRect.top;

                const boardPaddingTop = parseFloat(boardComputedStyle.paddingTop);
                const boardPaddingBottom = parseFloat(boardComputedStyle.paddingBottom);
                const boardContentHeight = elements.gameBoard.clientHeight - boardPaddingTop - boardPaddingBottom;
                const cellHeight = (boardContentHeight - (gameState.settings.rows - 1) * gap) / gameState.settings.rows;

                // Calculate target vertical center relative to the falling disc layer
                const targetTop = boardPaddingTop + targetRow * (cellHeight + gap) + gap / 2;

                // Calculate fall time based on distance - more consistent timing
                const fallDistance = targetTop + (discSize * 2); // Add the initial offset
                const fallTime = Math.min(600, Math.max(300, Math.abs(fallDistance) * 1.0));

                // Use transform for better performance and add bounce effect with cubic-bezier
                fallingDisc.style.transition = `transform ${fallTime}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;

                fallingDisc.style.boxShadow = '0 8px 20px rgba(0,0,0,0.5), inset 0 0px 8px rgba(255, 255, 255, 0.3)';
                // After the disc lands and before removing it, you could transition to the final shadow
                setTimeout(() => {
                    fallingDisc.style.boxShadow = 'inset 0 0px 8px rgba(255, 255, 255, 0.5), inset 0px 0px 15px rgba(0, 0, 0, 0.3)';
                }, fallTime - 100);

                // Start fall animation
                requestAnimationFrame(() => {
                    fallingDisc.style.transform = `translate(-50%, ${targetTop}px)`;
                });

                // Add subtle bounce effect using a second animation
                setTimeout(() => {
                    playSound(elements.discDropSound, 0.6);
                    // Quick bounce up
                    fallingDisc.style.transition = 'transform 120ms ease-out';
                    fallingDisc.style.transform = `translate(-50%, ${targetTop - (targetTop * 0.005)}px)`;

                    setTimeout(() => {
                        // Settle down
                        fallingDisc.style.transition = 'transform 80ms ease-in';
                        fallingDisc.style.transform = `translate(-50%, ${targetTop}px)`;

                        setTimeout(() => {
                            // Cleanup
                            fallingDisc.style.willChange = 'auto'; // Remove GPU optimization
                            fallingDisc.remove();
                            callback();
                        }, 80);
                    }, 120);
                }, fallTime);
            }

            function setInteractionState(enabled) {
                gameState.isInputEnabled = enabled;
                elements.gameBoard.style.pointerEvents = enabled ? 'auto' : 'none';
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.tabIndex = enabled ? 0 : -1;
                });
            }

            function getNextAvailableRow(col) {
                for (let r = gameState.settings.rows - 1; r >= 0; r--) {
                    if (gameState.board[r][col] === 0) {
                        return r;
                    }
                }
                return -1;
            }

            function isBoardFull() {
                return gameState.board[0].every(cell => cell !== 0);
            }

            function checkWin(r, c) {
                const playerId = gameState.board[r][c];
                const winLength = gameState.settings.winCondition;
                const directions = [
                    [0, 1], // horizontal
                    [1, 0], // vertical
                    [1, 1], // diagonal /
                    [1, -1] // diagonal \
                ];

                for (const [dr, dc] of directions) {
                    if (!gameState.settings.enableDiagonal && (dr === 1 && dc !== 0)) continue;
                    const cells = [];
                    for (let dir = -1; dir <= 1; dir += 2) {
                        for (let i = 1; i < winLength; i++) {
                            const nr = r + dr * i * dir;
                            const nc = c + dc * i * dir;
                            if (nr >= 0 && nr < gameState.settings.rows &&
                                nc >= 0 && nc < gameState.settings.cols &&
                                gameState.board[nr][nc] === playerId) {
                                cells.push([nr, nc]);
                            } else {
                                break;
                            }
                        }
                    }
                    cells.push([r, c]);
                    if (cells.length >= winLength) {
                        gameState.winningCells = cells.slice(0, winLength);
                        return gameState.players[playerId - 1];
                    }
                }
                return null;
            }

            function checkFixedTurnEnd() {
                return gameState.turnsTaken.every(turns => turns >= gameState.settings.turnLimit);
            }

            function determineFixedTurnWinner() {
                const discCounts = Array(gameState.players.length).fill(0);
                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        if (gameState.board[r][c] > 0) {
                            discCounts[gameState.board[r][c] - 1]++;
                        }
                    }
                }
                const maxDiscs = Math.max(...discCounts);
                const winners = gameState.players.filter((p, i) => discCounts[i] === maxDiscs);
                if (winners.length > 1) {
                    return {
                        message: "It's a draw!",
                        winner: null
                    };
                } else {
                    return {
                        message: `${winners[0].name} wins with ${maxDiscs} discs!`,
                        winner: winners[0]
                    };
                }
            }

            function nextTurn() {
                gameState.turnsTaken[gameState.currentPlayerIndex]++;

                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                gameState.lastHintColumn = -1;

                // Reset and start turn timer if applicable for timed modes
                if (gameState.settings.gameMode === 'timed' && gameState.settings.turnTimeLimit > 0) {
                    resetTurnTimer(); // properly resets the time
                    startTurnTimer(); // checks for AI players
                }

                const currentPlayer = gameState.players[gameState.currentPlayerIndex];

                if (!gameState.gameOver) {
                    if (currentPlayer.isAI) {
                        setInteractionState(false);
                        setTimeout(() => aiMove(currentPlayer.difficulty), 1000);
                    } else {
                        setInteractionState(true);
                    }
                } else {
                    setInteractionState(true);
                }

                updateDisplay();
            }


            function endGame(message, winner = null) {
                // Play appropriate sound
                if (winner) {
                    if (winner.isAI) {
                        playSound(elements.computerWinSound, 0.8);
                    } else {
                        playSound(elements.winSound, 0.8);
                    }
                } else {
                    playSound(elements.buttonClickSound, 0.5);
                }

                gameState.gameOver = true;
                gameState.gameOverMessage = message;
                gameState.winner = winner;
                clearTimers();

                setInteractionState(true);

                // Show the modal
                elements.winnerMessage.textContent = message;
                showModal();

                updateDisplay();
            }

            function showModal() {
                elements.winnerModal.classList.remove('hidden');

                // Focus the first button
                elements.playAgainBtn.focus();

                // Add escape key listener
                document.addEventListener('keydown', handleModalKeydown);

                // Store the previously focused element to restore later
                elements.winnerModal.previouslyFocused = document.activeElement;
            }

            function hideModal() {
                elements.winnerModal.classList.add('hidden');

                // Remove escape key listener
                document.removeEventListener('keydown', handleModalKeydown);

                // Clean up any leftover visual states that might interfere with rendering
                document.querySelectorAll('.column-highlight').forEach(el => {
                    el.classList.remove('column-highlight');
                });
                document.querySelectorAll('.hint-highlight').forEach(el => {
                    el.classList.remove('hint-highlight');
                });

                // CRITICAL: Recalculate mask after modal closes to fix layer alignment
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // Double RAF ensures layout is fully settled after modal removal
                        if (gameState.board && gameState.board.length > 0) {
                            // Force a complete re-render to recalculate mask coordinates
                            renderBoard();
                        }
                    });
                });

                // Restore focus to previously focused element
                if (elements.winnerModal.previouslyFocused) {
                    elements.winnerModal.previouslyFocused.focus();
                    // Clear the reference
                    elements.winnerModal.previouslyFocused = null;
                }
            }

            function handleModalKeydown(e) {
                if (e.key === 'Escape') {
                    hideModal();
                }

                // Simple focus trapping
                if (e.key === 'Tab') {
                    const focusableElements = elements.winnerModal.querySelectorAll('button');
                    const firstElement = focusableElements[0];
                    const lastElement = focusableElements[focusableElements.length - 1];

                    if (e.shiftKey && document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    } else if (!e.shiftKey && document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }

            function updateDisplay() {
                updateStatus();
                updateTimerDisplay();
            }

            function updateStatus() {
                if (gameState.gameOver) {
                    // If the game is over, display the game over message.s.
                    elements.statusMessage.textContent = gameState.winner ?
                        `Game Over - ${gameState.winner.name} wins!` : 'Game Over - Draw!';
                    return; // Exit the function as game is over.
                }

                if (gameState.isPaused) {
                    // If the game is paused, display "Game Paused" without player info.
                    elements.statusMessage.textContent = 'Game Paused';
                } else {
                    // If the game is not paused and not over, display the current player's turn.
                    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                    if (currentPlayer) {
                        let statusText = `${currentPlayer.name}'s Turn`;
                        if (gameState.settings.gameMode === 'fixed_turn') {
                            statusText += ` (${gameState.turnsTaken[gameState.currentPlayerIndex] + 1}/${gameState.settings.turnLimit})`;
                        }
                        // Use innerHTML to include the colored circle for the current player.
                        elements.statusMessage.innerHTML = `
                <span class="inline-block w-5 h-5 rounded-full mr-2"
                      style="background-color: ${currentPlayer.color};"
                      aria-hidden="true"></span>
                ${statusText}
            `;
                    } else {
                        // Fallback if currentPlayer is somehow not defined (shouldn't happen in normal play).
                        elements.statusMessage.textContent = 'Starting Game...';
                    }
                }
            }

            function updateTimerDisplay() {
                if (gameState.settings.gameMode !== 'timed') {
                    elements.timerDisplay.textContent = '';
                    return;
                }
                const gameMinutes = Math.floor(gameState.timers.remainingGameTime / 60);
                const gameSeconds = gameState.timers.remainingGameTime % 60;
                let display = `Game: ${gameMinutes}:${gameSeconds.toString().padStart(2, '0')}`;
                if (gameState.settings.turnTimeLimit > 0) {
                    display += ` | Turn: ${gameState.timers.remainingTurnTime}s`;
                }
                elements.timerDisplay.textContent = display;
            }

            function updateMoveHistory() {
                const history = gameState.moveHistory.slice(-10);
                elements.historyList.innerHTML = history.map((move, index) => {
                    const moveNumber = gameState.moveHistory.length - history.length + index + 1;
                    const player = gameState.players[move.player];
                    return `<div class="mb-1">
                        <span style="color: ${player.color};">●</span>
                        Move ${moveNumber}: ${player.name} → Column ${move.col + 1}
                    </div>`;
                }).join('');

                requestAnimationFrame(() => {
                    renderBoard();
                });
            }

            // --- Timer Functions ---
            function clearTimers() {
                if (gameState && gameState.timers) {
                    if (gameState.timers.gameTimerId) {
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                    }
                    if (gameState.timers.turnTimerId) {
                        clearInterval(gameState.timers.turnTimerId);
                        gameState.timers.turnTimerId = null;
                    }
                }
            }

            function startGameTimer() {
                // Clear any existing interval before setting a new one to prevent duplicates
                if (gameState.timers.gameTimerId) {
                    clearInterval(gameState.timers.gameTimerId);
                }

                gameState.timers.gameTimerId = setInterval(() => {
                    if (gameState.gameOver || gameState.isPaused) {
                        return;
                    }

                    gameState.timers.remainingGameTime--;
                    updateTimerDisplay();

                    if (gameState.timers.remainingGameTime <= 0) {
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                        endGame("Time's up! It's a draw!");
                    }
                }, 1000);
            }

            function startTurnTimer() {
                // Don't start turn timer for AI players
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) {
                    return;
                }

                // Clear any existing interval before setting a new one
                if (gameState.timers.turnTimerId) {
                    clearInterval(gameState.timers.turnTimerId);
                }

                // Only start timer if turn time limit is set
                if (gameState.settings.turnTimeLimit <= 0) {
                    return;
                }

                gameState.timers.turnTimerId = setInterval(() => {
                    if (gameState.gameOver || gameState.isPaused) {
                        clearInterval(gameState.timers.turnTimerId);
                        gameState.timers.turnTimerId = null;
                        return;
                    }

                    gameState.timers.remainingTurnTime--;
                    updateTimerDisplay();

                    if (gameState.timers.remainingTurnTime <= 0) {
                        clearInterval(gameState.timers.turnTimerId);
                        gameState.timers.turnTimerId = null;
                        playSound(elements.errorSound, 0.4);
                        nextTurn();
                    }
                }, 1000);
            }


            function resetTurnTimer() {
                if (gameState.timers.turnTimerId) {
                    clearInterval(gameState.timers.turnTimerId);
                    gameState.timers.turnTimerId = null;
                }
                gameState.timers.remainingTurnTime = gameState.settings.turnTimeLimit;
            }

            // --- AI Functions ---
            function aiMove(difficulty) {
                if (gameState.gameOver) return;
                let col;
                switch (difficulty) {
                    case 'easy':
                        col = getEasyAIMove();
                        break;
                    case 'medium':
                        col = getMediumAIMove();
                        break;
                    case 'hard':
                        col = getHardAIMove();
                        break;
                    default:
                        col = getMediumAIMove();
                }
                if (col !== -1) {
                    makeMove(col);
                }
            }

            function getValidMoves() {
                const validCols = [];
                for (let c = 0; c < gameState.settings.cols; c++) {
                    if (getNextAvailableRow(c) !== -1) {
                        validCols.push(c);
                    }
                }
                return validCols;
            }

            function getEasyAIMove() {
                const validCols = getValidMoves();
                return validCols.length > 0 ?
                    validCols[Math.floor(Math.random() * validCols.length)] : -1;
            }

            function getMediumAIMove() {
                const validCols = getValidMoves();
                if (validCols.length === 0) return -1;

                const aiId = gameState.players[gameState.currentPlayerIndex].id;
                let bestScore = -Infinity;
                let bestCol = validCols[0];

                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = aiId;
                    const score = minimax(4, false, -Infinity, Infinity, gameState.currentPlayerIndex);
                    gameState.board[row][col] = 0;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCol = col;
                    }
                }
                return bestCol;
            }

            /**
             * Determines the best move for the Hard AI by using the minimax algorithm
             * with a greater search depth for more strategic analysis.
             */
            function getHardAIMove() {
                const validCols = getValidMoves();
                if (validCols.length === 0) return -1;

                const aiId = gameState.players[gameState.currentPlayerIndex].id;
                let bestScore = -Infinity;
                let bestCol = validCols[Math.floor(Math.random() * validCols.length)]; // Start with a random valid move

                // The hard AI uses a deeper search (e.g., depth 6)
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    if (row === -1) continue;

                    gameState.board[row][col] = aiId;
                    const score = minimax(6, false, -Infinity, Infinity, gameState.currentPlayerIndex);
                    gameState.board[row][col] = 0; // Backtrack

                    if (score > bestScore) {
                        bestScore = score;
                        bestCol = col;
                    }
                }
                return bestCol;
            }

            function minimax(depth, isMaximizing, alpha, beta, originalAI) {
                const winnerInfo = checkForTerminalState();
                if (depth === 0 || winnerInfo.isTerminal) {
                    if (winnerInfo.isTerminal) {
                        if (winnerInfo.winner === null) return 0; // Draw
                        if (winnerInfo.winner === originalAI) return 100000 + depth; // AI wins
                        return -100000 - depth; // Opponent wins
                    }
                    return evaluateBoard(originalAI); // Evaluate board state
                }

                const validCols = getValidMoves();
                const currentPlayerId = gameState.players[gameState.currentPlayerIndex].id;

                if (isMaximizing) {
                    let maxScore = -Infinity;
                    for (const col of validCols) {
                        const row = getNextAvailableRow(col);
                        gameState.board[row][col] = currentPlayerId;

                        const nextPlayer = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                        const originalPlayer = gameState.currentPlayerIndex;
                        gameState.currentPlayerIndex = nextPlayer;

                        const score = minimax(depth - 1, originalAI === nextPlayer, alpha, beta, originalAI);

                        gameState.currentPlayerIndex = originalPlayer;
                        gameState.board[row][col] = 0; // Backtrack

                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break;
                    }
                    return maxScore;
                } else { // Minimizing player
                    let minScore = Infinity;
                    for (const col of validCols) {
                        const row = getNextAvailableRow(col);
                        gameState.board[row][col] = currentPlayerId;

                        const nextPlayer = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                        const originalPlayer = gameState.currentPlayerIndex;
                        gameState.currentPlayerIndex = nextPlayer;

                        const score = minimax(depth - 1, originalAI === nextPlayer, alpha, beta, originalAI);

                        gameState.currentPlayerIndex = originalPlayer;
                        gameState.board[row][col] = 0; // Backtrack

                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break;
                    }
                    return minScore;
                }
            }

            function checkForTerminalState() {
                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        if (gameState.board[r][c] !== 0) {
                            const winner = checkWin(r, c);
                            if (winner) {
                                return { isTerminal: true, winner: winner.id - 1 };
                            }
                        }
                    }
                }
                if (isBoardFull()) {
                    return { isTerminal: true, winner: null }; // Draw
                }
                return { isTerminal: false, winner: null };
            }

            /**
             * Evaluates a single "window" of cells (a potential winning line) and returns a score.
             * This is the core of the AI's intelligence.
             * @param {Array<number>} window - An array of cells.
             * @param {number} aiId - The ID of the AI player.
             * @returns {number} The score for this window.
             */
            function evaluateWindow(window, aiId) {
                const winCondition = gameState.settings.winCondition;
                let aiCount = 0;
                let opponentCount = 0;
                let emptyCount = 0;

                for (const piece of window) {
                    if (piece === aiId) {
                        aiCount++;
                    } else if (piece === 0) {
                        emptyCount++;
                    } else {
                        opponentCount++;
                    }
                }

                // If a line contains pieces from both players, it can never result in a win.
                if (aiCount > 0 && opponentCount > 0) {
                    return 0;
                }

                // AI is about to win
                if (aiCount === winCondition - 1 && emptyCount === 1) return 100;
                // AI is setting up a good position
                if (aiCount === winCondition - 2 && emptyCount === 2) return 10;
                // AI has a minor advantage
                if (aiCount === winCondition - 3 && emptyCount === 3) return 5;

                // Opponent is about to win (must block!)
                if (opponentCount === winCondition - 1 && emptyCount === 1) return -500;
                // Opponent is setting up
                if (opponentCount === winCondition - 2 && emptyCount === 2) return -50;

                return 0;
            }

            /**
             * Evaluates the entire board and returns a score representing the AI's advantage.
             * A positive score favors the AI, a negative score favors the opponent.
             * @param {number} aiId - The ID of the AI player.
             * @returns {number} The total score for the board.
             */
            function evaluateBoard(aiId) {
                let score = 0;
                const rows = gameState.settings.rows;
                const cols = gameState.settings.cols;
                const winCondition = gameState.settings.winCondition;

                // Center column preference
                const centerCol = Math.floor(cols / 2);
                for (let r = 0; r < rows; r++) {
                    if (gameState.board[r][centerCol] === aiId) {
                        score += 3;
                    }
                }

                // Horizontal windows
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c <= cols - winCondition; c++) {
                        const window = [];
                        for (let i = 0; i < winCondition; i++) {
                            window.push(gameState.board[r][c + i]);
                        }
                        score += evaluateWindow(window, aiId);
                    }
                }

                // Vertical windows
                for (let c = 0; c < cols; c++) {
                    for (let r = 0; r <= rows - winCondition; r++) {
                        const window = [];
                        for (let i = 0; i < winCondition; i++) {
                            window.push(gameState.board[r + i][c]);
                        }
                        score += evaluateWindow(window, aiId);
                    }
                }

                // Positive slope diagonal windows (/)
                for (let r = 0; r <= rows - winCondition; r++) {
                    for (let c = 0; c <= cols - winCondition; c++) {
                        const window = [];
                        for (let i = 0; i < winCondition; i++) {
                            window.push(gameState.board[r + i][c + i]);
                        }
                        score += evaluateWindow(window, aiId);
                    }
                }

                // Negative slope diagonal windows (\)
                for (let r = winCondition - 1; r < rows; r++) {
                    for (let c = 0; c <= cols - winCondition; c++) {
                        const window = [];
                        for (let i = 0; i < winCondition; i++) {
                            window.push(gameState.board[r - i][c + i]);
                        }
                        score += evaluateWindow(window, aiId);
                    }
                }

                return score;
            }

            // --- Game Controls ---
            function togglePause() {
                if (gameState.gameOver) return;

                gameState.isPaused = !gameState.isPaused;
                elements.pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';

                if (gameState.isPaused) {
                    // Store timer states but don't clear the actual time values
                    gameState.timers.gamePaused = gameState.timers.gameTimerId !== null;
                    gameState.timers.turnPaused = gameState.timers.turnTimerId !== null;

                    // Clear the intervals
                    clearTimers();
                } else {
                    // Resume timers based on stored states
                    if (gameState.settings.gameMode === 'timed') {
                        if (gameState.timers.gamePaused && gameState.timers.remainingGameTime > 0) {
                            startGameTimer();
                        }
                        if (gameState.timers.turnPaused && gameState.timers.remainingTurnTime > 0) {
                            startTurnTimer();
                        }
                    }
                    // Reset pause states
                    gameState.timers.gamePaused = false;
                    gameState.timers.turnPaused = false;
                }
                updateDisplay();
            }

            // Ensure your timer functions are set up to be called multiple times
            // and handle clearing previous intervals if they are called when one is already running.

            function startGameTimer() {
                // Clear any existing interval before setting a new one to prevent duplicates
                if (gameState.timers.gameTimerId) {
                    clearInterval(gameState.timers.gameTimerId);
                }
                gameState.timers.gameTimerId = setInterval(() => {
                    if (gameState.gameOver) { // Only check for game over, isPaused is handled in togglePause
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                        return;
                    }
                    gameState.timers.remainingGameTime--;
                    updateTimerDisplay();
                    if (gameState.timers.remainingGameTime <= 0) {
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                        endGame("Time's up! It's a draw!");
                    }
                }, 1000);
            }


            function undoMove() {
                if (gameState.moveHistory.length === 0 || gameState.gameOver) return;
                const lastMove = gameState.moveHistory.pop();
                gameState.board = lastMove.boardState;
                gameState.turnsTaken[lastMove.player]--;
                gameState.currentPlayerIndex = lastMove.player;
                gameState.winningCells = [];
                renderBoard(); // Re-render to reflect undone move
                updateMoveHistory();
                elements.undoBtn.disabled = gameState.moveHistory.length === 0;
                updateDisplay();
            }

            function showHint() {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer.isAI) return;

                document.querySelectorAll('.hint-highlight').forEach(el => {
                    el.classList.remove('hint-highlight');
                });

                const col = getMediumAIMove();
                if (col !== -1) {
                    gameState.lastHintColumn = col;
                    for (let r = 0; r < gameState.settings.rows; r++) {
                        const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${col}']`);
                        if (cell) {
                            cell.classList.add('column-highlight'); // Use class for highlight
                            setTimeout(() => {
                                cell.classList.remove('column-highlight');
                            }, 2000);
                        }
                    }
                }
            }

            function saveGame() {
                if (!gameState.isPaused && !gameState.gameOver) {
                    alert('Please pause the game before saving.');
                    return;
                }
                try {
                    const saveData = {
                        version: SAVE_FILE_VERSION,
                        gameState: gameState,
                        timestamp: new Date().toISOString()
                    };
                    const blob = new Blob([JSON.stringify(saveData, null, 2)], {
                        type: 'application/json'
                    });
                    const now = new Date();
                    const timestamp = now.toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
                    const filename = `connect4_${gameState.settings.gameMode}_${timestamp}.json`;
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                } catch (error) {
                    console.error('Save failed:', error);
                    alert('Failed to save game. Please try again.');
                }
            }

            function loadGame(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const saveData = JSON.parse(e.target.result);
                        if (!saveData.version || !saveData.gameState) {
                            throw new Error('Invalid save file format');
                        }
                        if (saveData.version !== SAVE_FILE_VERSION) {
                            if (!confirm('This save file is from a different version. Loading may cause issues. Continue?')) {
                                return;
                            }
                        }
                        cleanupGame();
                        gameState = saveData.gameState;

                        // Restore UI settings
                        elements.boardRowsInput.value = gameState.settings.rows;
                        elements.boardColsInput.value = gameState.settings.cols;
                        elements.winConditionInput.value = gameState.settings.winCondition;
                        elements.enableDiagonalCheckbox.checked = gameState.settings.enableDiagonal;
                        elements.gameModeSelect.value = gameState.settings.gameMode;
                        elements.timeLimitSelect.value = gameState.settings.timeLimit;
                        elements.turnTimeLimitSelect.value = gameState.settings.turnTimeLimit;
                        elements.turnLimitInput.value = gameState.settings.turnLimit;
                        elements.playerModeSelect.value = gameState.settings.playerMode;

                        updateGameModeOptionsVisibility();
                        updatePlayerInputs();

                        // Restore board color
                        elements.boardVisualLayer.style.backgroundColor = elements.boardColorSelect.value;

                        renderBoard(); // Re-render board with new settings and mask
                        updateMoveHistory();
                        updateDisplay();

                        if (gameState.settings.gameMode === 'timed' && !gameState.gameOver) {
                            if (!gameState.isPaused) {
                                startGameTimer();
                                if (gameState.settings.turnTimeLimit > 0) {
                                    startTurnTimer();
                                }
                            }
                        }
                        elements.pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';
                        elements.undoBtn.disabled = gameState.moveHistory.length === 0;
                        event.target.value = '';
                        alert('Game loaded successfully!');

                    } catch (error) {
                        console.error('Load failed:', error);
                        alert('Failed to load game file. Please check the file and try again.');
                    }
                };
                reader.readAsText(file);
            }

            // --- Initialize Game ---
            init();
        });
    </script>
</body>

</html>