<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for the document and theme variables */
        :root {
            --background-light: #f3f4f6;
            --text-light: #1f2937;
            --board-bg-light: #4b5563;
            --background-dark: #1f2937;
            --text-dark: #f3f4f6;
            --board-bg-dark: #374151;
        }

        html {
            scrollbar-gutter: stable;
        }

        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        /* Dark theme variables */
        .dark {
            --background: var(--background-dark);
            --text: var(--text-dark);
            --board-bg: var(--board-bg-dark);
        }

        /* Light theme variables */
        .light {
            --background: var(--background-light);
            --text: var(--text-light);
            --board-bg: var(--board-bg-light);
        }

        button#start-game-btn-mobile {
            display: none;
        }

        /* The .hole div is no longer used for visual holes, so hide it */
        .hole {
            display: none;
        }

        /* Styling for each cell on the game board (now just interactive areas) */
        .cell {
            position: relative;
            overflow: hidden;
            border-radius: 50%;
            box-shadow: inset 15px 15px 8px rgba(0, 0, 0, 0.3), -5px -5px 6px #ffffff44, 3px 5px 8px #00000055;
            outline: 2px solid #ffffff40;
            border: 3px solid #e7e7e740;
        }

        /* Styling for a disc (after landing) */
        .disc {
            width: calc(90% + 6px);
            aspect-ratio: 1;
            border-radius: 50%;
            box-shadow: inset 0 0px 4px rgba(255, 255, 255, 0.4),
                inset 0px 0px 8px rgba(0, 0, 0, 0.2);
            z-index: -3;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .disc::after {
            content: ' ';
            position: absolute;
            width: 90%;
            aspect-ratio: 1;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0) 33%, rgba(0, 0, 0, 0.15) 46%, rgba(0, 0, 0, 0) 46%, rgba(255, 255, 255, 0.25) 50%, rgba(0, 0, 0, 0.2) 53%, rgb(255, 255, 255, 0%) 63%, rgb(255, 255, 255, 0.25) 66%, rgb(0 0 0 / 25%) 72%, rgb(255, 255, 255, 20%) 78%);
            z-index: -2;
        }

        /* Styling for the disc during the falling animation */
        .falling-disc {
            position: absolute;
            pointer-events: none;
        }

        /* Highlight for columns on hover */
        .column-highlight {
            /* background: rgba(255, 255, 255, 0.1); */
            outline: #e5e7eb solid 1px !important;
            cursor: pointer;
        }

        /* Modal backdrop for pop-ups */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        /* Content area for modals */
        .modal-content {
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw;
        }

        /* Styling for the game board container - the main wrapper */
        #game-board-container {
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            border-radius: 2%;
            aspect-ratio: var(--board-aspect-ratio, 7/6);
        }

        /* Layer for falling discs only */
        #falling-disc-layer {
            position: absolute;
            inset: 0;
            z-index: -2;
        }

        /* Layer for the board visual with holes (the mask will be here) */
        #board-visual-layer {
            position: absolute;
            inset: 0;
            z-index: 1;
            background-color: var(--board-bg);
            mask-image: none;
            mask-mode: alpha;
            mask-composite: exclude;
            -webkit-mask-image: none;
            -webkit-mask-mode: alpha;
            -webkit-mask-composite: exclude;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 4px 15px rgba(0, 0, 0, 0.2);
            border-radius: 2%;
        }

        /* The interactive grid (cells for click events) - no visual background */
        #game-board {
            position: relative;
            inset: 0;
            z-index: 2;
            padding: 12px;
            height: 100%;
            display: grid;
            gap: 12px;
        }

        /* Screen reader only text */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus styles for interactive elements */
        .focus-visible:focus {
            background-color: #f0f0f075;
        }

        /* Keyboard navigation focus style */
        .keyboard-focus {
            outline: aliceblue auto 5px !important;
        }

        #board-visual-layer {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        /* Color dropdown styles */
        .color-dropdown {
            position: relative;
            display: inline-block;
        }

        .color-dropdown-button {
            width: 4rem;
            height: 2.5rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-dropdown-content {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1000;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.25rem;
            width: 120px;
        }

        .color-dropdown-content.show {
            display: grid;
        }

        .color-option {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: #374151;
        }

        .color-option.selected {
            border-color: #1f2937;
            border-width: 3px;
        }

        /* Dark theme styles */
        .dark .color-dropdown-content {
            background: #374151;
            border-color: #6b7280;
        }

        .dark .color-option {
            border-color: #6b7280;
        }

        .dark .color-option:hover {
            border-color: #f3f4f6;
        }

        .dark .color-option.selected {
            border-color: #f3f4f6;
        }

        .modal-content,
        aside,
        button,
        select,
        input,
        #game-info {
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }

        /* Layout specific styles */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        .game-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
            align-items: start;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @keyframes details-show {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 1024px) {
            .game-layout {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0.5rem;
            }

            .modal-content {
                padding: 1.5rem;
                margin: 1rem;
            }

            #game-board-container {
                max-width: 100%;
                margin: 0 auto;
                box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.15),
                    0 1px 4px rgba(0, 0, 0, 0.1);
            }

            .disc {
                width: 95%;
                height: 95%;
                border: 0.5px solid rgba(0, 0, 0, 0.1);
                box-shadow: inset 0 0px 2px rgba(255, 255, 255, 0.3),
                    inset 0px 0px 4px rgba(0, 0, 0, 0.15);
            }

            .dark .disc {
                border: 0.5px solid rgba(255, 255, 255, 0.1);
                box-shadow: inset 0 0px 2px rgba(255, 255, 255, 0.2),
                    inset 0px 0px 4px rgba(0, 0, 0, 0.3);
            }

            #board-visual-layer {
                box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.15),
                    0 1px 4px rgba(0, 0, 0, 0.1);
            }

            .cell.aspect-square.flex.justify-center.items-center {
                box-shadow: inset 0px -12px 10px rgba(0, 0, 0, 0.3), -2px -2px 8px rgba(231, 231, 231, 0.3), 2px 2px 8px rgba(0, 0, 0, 0.3);
                border: 3px solid rgba(255, 255, 255, 0.3);
            }

            .falling-disc {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2),
                    inset 0 0px 2px rgba(255, 255, 255, 0.15);
            }

            .column-highlight {
                background: rgba(255, 255, 255, 0.15);
                cursor: pointer;
            }

            .dark .column-highlight {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        @media (max-width: 480px) {
            button#start-game-btn {
                display: none;
            }

            button#start-game-btn-mobile {
                display: inline-flex;
                justify-content: center;
                width: 100%;
            }

            #game-board {
                gap: 6px;
                padding: 9px;
            }

            .disc {
                box-shadow: inset 0 0px 1px rgba(255, 255, 255, 0.2),
                    inset 0px 0px 2px rgba(0, 0, 0, 0.1);
            }

            #game-board-container,
            #board-visual-layer {
                box-shadow: inset 0 0 2px rgba(0, 0, 0, 0.1),
                    0 1px 2px rgba(0, 0, 0, 0.08);
            }

            .cell.aspect-square.flex.justify-center.items-center {
                box-shadow: inset 0px -6px 8px rgba(0, 0, 0, 0.3),
                    -2px -2px 8px rgba(231, 231, 231, 0.3),
                    2px 2px 8px rgba(0, 0, 0, 0.3);
                border: 1.5px solid rgba(231, 231, 231, 0.1);
                outline: 1px outset #ffffff40;
            }

            .falling-disc {
                box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15),
                    inset 0 0px 1px rgba(255, 255, 255, 0.1);
            }

            .text-center:has(.player-status-section) {
                flex-direction: column-reverse;
                row-gap: 1rem;
            }

            #game-info>p {
                box-sizing: border-box;
            }

            #game-controls {
                justify-content: space-between;
            }

            #player-colors-container>div {
                display: grid;
                grid-template-columns: repeat(6, 1fr);
                grid-template-areas: "color-dropdown name name name name name";
                gap: 1rem;
                margin-bottom: 0;
            }

            #player-colors-container .color-dropdown {
                grid-area: color-dropdown;
            }

            #player-colors-container input {
                grid-area: name;
            }
        }
    </style>
</head>

<body class="light bg-[var(--background)] text-[var(--text)]" role="main">

    <div class="main-container">
        <!-- Title Section -->
        <div class="text-center mb-6 flex items-center justify-between">
            <!-- <div class="inline-block px-8 py-4 rounded-lg shadow-lg">
                <h1 class="text-6xl font-bold text-black">Connect</h1>
            </div> -->

            <!-- Player Status Section -->
            <div class="player-status-section">
                <div id="game-info" class="text-center flex items-center justify-around">
                    <p id="status-message" class="text-xl font-medium flex items-center justify-center ml-4"
                        aria-live="polite">Ready to play!</p>
                    <p id="timer-display" class="text-sm text-gray-600 dark:text-gray-400 ml-4" aria-live="polite"></p>
                </div>
            </div>

            <button id="start-game-btn"
                class="top px-8 py-3 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition-colors items-center">
                Start New Game
            </button>

        </div>

        <!-- Main Game Layout -->
        <div class="game-layout">
            <!-- Left Side - Game Area -->
            <div class="game-area">


                <!-- Game Board Section -->
                <div class="game-board-section">
                    <div id="game-board-container" class="mx-auto aspect-[7/6] max-w-full rounded-lg shadow-lg">
                        <!-- Layer for falling discs only -->
                        <div id="falling-disc-layer" class="absolute inset-0 overflow-visible"></div>

                        <!-- Layer for the board visual with holes (the mask will be here) -->
                        <div id="board-visual-layer" class="absolute inset-0"></div>

                        <!-- The interactive grid (cells for click events) - no visual background -->
                        <div id="game-board" class="h-full" role="grid" aria-label="Connect 4 game board">
                            <!-- Game board cells will be generated here -->
                        </div>
                    </div>
                </div>

                <!-- Game Controls Section -->
                <div class="controls-section">
                    <button id="start-game-btn-mobile"
                        class="bottom px-8 py-3 mb-4 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition-colors items-center">
                        Start New Game
                    </button>

                    <div id="game-controls" class="flex justify-center gap-2">

                        <button id="pause-btn"
                            class="px-4 py-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 focus-visible:focus transition-colors"
                            aria-label="Pause game">
                            Pause
                        </button>
                        <button id="undo-btn"
                            class="px-4 py-2 bg-orange-500 text-white rounded-lg shadow hover:bg-orange-600 focus-visible:focus transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            aria-label="Undo last move" disabled>
                            Undo
                        </button>
                        <button id="save-btn"
                            class="px-4 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 focus-visible:focus transition-colors"
                            aria-label="Save current game">
                            Save
                        </button>
                        <label
                            class="px-4 py-2 bg-yellow-500 text-white rounded-lg shadow hover:bg-yellow-600 cursor-pointer focus-within:ring-2 focus-within:ring-yellow-300 transition-colors">
                            Load
                            <input type="file" id="load-game-input" class="sr-only" accept=".json"
                                aria-label="Load saved game">
                        </label>
                    </div>

                    <div id="move-history" class="mt-4 text-center">
                        <h3 class="text-lg font-semibold mb-2">Move History</h3>
                        <div id="history-list"
                            class="text-sm text-gray-600 dark:text-gray-400 max-h-32 overflow-y-scroll">
                            <!-- Move history will appear here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Side - Settings Panel -->
            <aside class="bg-slate-700 text-white p-6 rounded-lg shadow-md">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-white">Game Settings</h2>
                </div>

                <details open>
                    <summary class="text-xl font-bold mb-4 border-b pb-2 cursor-pointer">Configuration</summary>
                    <div class="details-content">
                        <!-- Theme Settings -->
                        <div class="mb-4">
                            <label class="block font-medium mb-2">Theme</label>
                            <div class="flex gap-2">
                                <button id="light-mode-btn"
                                    class="flex-1 px-4 py-2 bg-gray-200 text-gray-900 rounded-lg focus-visible:focus transition-colors">Light</button>
                                <button id="dark-mode-btn"
                                    class="flex-1 px-4 py-2 bg-gray-600 text-white rounded-lg focus-visible:focus transition-colors">Dark</button>
                            </div>
                        </div>

                        <!-- Board Color -->
                        <div class="mb-4">
                            <label for="board-color" class="block font-medium mb-1">Board Color</label>
                            <select id="board-color"
                                class="w-full p-2 rounded bg-white text-black border focus-visible:focus">
                                <option value="#1469f4">Blue</option>
                                <option value="#4b5563">Gray</option>
                                <option value="#8b5cf6">Purple</option>
                                <option value="#00bd13">Green</option>
                            </select>
                        </div>

                        <!-- Game Mode -->
                        <div class="mb-4">
                            <label for="game-mode" class="block font-medium mb-1">Game Mode</label>
                            <select id="game-mode"
                                class="w-full p-2 rounded bg-white text-black border focus-visible:focus">
                                <option value="classic">Classic</option>
                                <option value="timed">Timed</option>
                                <option value="fixed_turn">Fixed Turn</option>
                            </select>
                        </div>

                        <!-- Timed Mode Options -->
                        <div id="timed-options" class="hidden mb-4 pl-4 border-l-2 border-blue-300">
                            <label for="time-limit" class="block font-medium mb-1">Game Time Limit</label>
                            <select id="time-limit"
                                class="w-full p-2 rounded bg-white text-black border mb-2 focus-visible:focus">
                                <option value="120">2 minutes</option>
                                <option value="300">5 minutes</option>
                                <option value="600">10 minutes</option>
                                <option value="1200">20 minutes</option>
                            </select>
                            <label for="turn-time-limit" class="block font-medium mb-1">Turn Time Limit</label>
                            <select id="turn-time-limit"
                                class="w-full p-2 rounded bg-white text-black border focus-visible:focus">
                                <option value="0">No Limit</option>
                                <option value="10">10 seconds</option>
                                <option value="15">15 seconds</option>
                                <option value="30">30 seconds</option>
                            </select>
                        </div>

                        <!-- Fixed Turn Options -->
                        <div id="fixed-turn-options" class="hidden mb-4 pl-4 border-l-2 border-green-300">
                            <label for="turn-limit" class="block font-medium mb-1">Turns per Player</label>
                            <input type="number" id="turn-limit" value="15" min="5" max="50"
                                class="w-full p-2 rounded bg-white text-black border focus-visible:focus">
                        </div>

                        <!-- Player Setup -->
                        <div class="mb-4">
                            <label for="player-mode" class="block font-medium mb-1">Players</label>
                            <select id="player-mode"
                                class="w-full p-2 rounded bg-white text-black border focus-visible:focus">
                                <option value="vs_com">vs Computer</option>
                                <option value="2_player">2 Players</option>
                                <option value="3_player">3 Players</option>
                                <option value="4_player">4 Players</option>
                            </select>
                        </div>

                        <!-- AI Settings -->
                        <div id="ai-settings-container" class="mb-4 pl-4 border-l-2 border-red-300">
                            <!-- AI difficulty settings will be generated here -->
                        </div>

                        <!-- Player Names -->
                        <div id="player-names-container" class="mb-4">
                            <label class="block font-medium mb-2">Customize Players Details</label>
                            <!-- Player name inputs will be generated here -->
                        </div>

                        <!-- Player Colors -->
                        <div id="player-colors-container" class="mb-4 space-y-2">
                            <!-- Player color inputs will be generated here -->
                        </div>

                        <!-- Board Size -->
                        <div class="mb-4">
                            <label class="block font-medium mb-1">Board Size</label>
                            <div class="flex gap-2 items-center">
                                <input type="number" id="board-cols" value="7" min="4" max="15"
                                    class="w-1/2 p-2 rounded bg-white text-black border focus-visible:focus"
                                    aria-label="Number of columns">
                                <span>×</span>
                                <input type="number" id="board-rows" value="6" min="4" max="15"
                                    class="w-1/2 p-2 rounded bg-white text-black border focus-visible:focus"
                                    aria-label="Number of rows">
                            </div>
                            <p class="text-xs text-gray-300 mt-1">Columns × Rows (4-15 each)</p>
                        </div>

                        <!-- Win Condition -->
                        <div class="mb-4">
                            <label for="win-condition" class="block font-medium mb-1">Discs to Win</label>
                            <input type="number" id="win-condition" value="4" min="3" max="8"
                                class="w-full p-2 rounded bg-white text-black border focus-visible:focus">
                            <p class="text-xs text-gray-300 mt-1">Must be ≤ smallest board dimension</p>
                        </div>

                        <!-- Diagonal Match -->
                        <div class="mb-6 flex items-center gap-2">
                            <input type="checkbox" id="enable-diagonal" class="h-5 w-5 rounded focus-visible:focus"
                                checked>
                            <label for="enable-diagonal">Enable Diagonal Matches</label>
                        </div>

                        <!-- Audio Settings -->
                        <div class="mb-4">
                            <div class="flex items-center gap-2 mb-2">
                                <input type="checkbox" id="enable-sound" class="h-5 w-5 rounded focus-visible:focus"
                                    checked>
                                <label for="enable-sound" class="font-medium">Enable Sound Effects</label>
                            </div>
                        </div>
                    </div>
                </details>
            </aside>
        </div>
    </div>

    <!-- Modal for Winner/Draw -->
    <div id="winner-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true"
        aria-labelledby="winner-message">
        <div class="modal-content bg-[var(--background)] text-[var(--text)] text-center">
            <h3 id="winner-message" class="text-3xl font-bold mb-4"></h3>
            <div class="flex gap-4 justify-center">
                <button id="play-again-btn"
                    class="px-6 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 focus-visible:focus transition-colors">
                    Play Again
                </button>
                <button id="close-modal-btn"
                    class="px-6 py-2 bg-gray-500 text-white rounded-lg shadow hover:bg-gray-600 focus-visible:focus transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Audio Elements -->
    <div id="audio-container" style="display: none;">
        <audio id="disc-drop-sound" preload="auto">
            <source src="sounds/disc-drop.mp3" type="audio/mpeg">
            <source src="sounds/disc-drop.wav" type="audio/wav">
        </audio>
        <audio id="win-sound" preload="auto">
            <source src="sounds/win.mp3" type="audio/mpeg">
            <source src="sounds/win.wav" type="audio/wav">
        </audio>
        <audio id="computer-win-sound" preload="auto">
            <source src="sounds/computer-win.mp3" type="audio/mpeg">
            <source src="sounds/computer-win.wav" type="audio/wav">
        </audio>
        <audio id="button-click-sound" preload="auto">
            <source src="sounds/button-click.mp3" type="audio/mpeg">
            <source src="sounds/button-click.wav" type="audio/wav">
        </audio>
        <audio id="column-hover-sound" preload="auto">
            <source src="sounds/hover.mp3" type="audio/mpeg">
            <source src="sounds/hover.wav" type="audio/wav">
        </audio>
        <audio id="error-sound" preload="auto">
            <source src="sounds/error.mp3" type="audio/mpeg">
            <source src="sounds/error.wav" type="audio/wav">
        </audio>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants ---
            const SAVE_FILE_VERSION = "1.0";
            const DEFAULT_PLAYER_COLORS = ['#ff0000', '#00ff00', '#ffff00', '#0000ff', '#ff00ff', '#00ffff', '#FF5F1F', '#ffffff', '#000000'];
            const ANIMATION_DURATION = 500; // milliseconds

            // --- DOM Elements ---
            const elements = {
                gameBoard: document.getElementById('game-board'), // Now the interactive grid
                statusMessage: document.getElementById('status-message'),
                timerDisplay: document.getElementById('timer-display'),
                boardContainer: document.getElementById('game-board-container'),
                winnerModal: document.getElementById('winner-modal'),
                winnerMessage: document.getElementById('winner-message'),
                historyList: document.getElementById('history-list'),
                fallingDiscLayer: document.getElementById('falling-disc-layer'), // Renamed
                boardVisualLayer: document.getElementById('board-visual-layer'), // Reference to the board visual layer
                // discLayer: document.getElementById('disc-layer'), // No longer needed for landed discs

                // Settings
                lightModeBtn: document.getElementById('light-mode-btn'),
                darkModeBtn: document.getElementById('dark-mode-btn'),
                boardColorSelect: document.getElementById('board-color'),
                gameModeSelect: document.getElementById('game-mode'),
                timedOptions: document.getElementById('timed-options'),
                timeLimitSelect: document.getElementById('time-limit'),
                turnTimeLimitSelect: document.getElementById('turn-time-limit'),
                fixedTurnOptions: document.getElementById('fixed-turn-options'),
                turnLimitInput: document.getElementById('turn-limit'),
                playerModeSelect: document.getElementById('player-mode'),
                aiSettingsContainer: document.getElementById('ai-settings-container'),
                playerNamesContainer: document.getElementById('player-names-container'),
                playerColorsContainer: document.getElementById('player-colors-container'),
                boardColsInput: document.getElementById('board-cols'),
                boardRowsInput: document.getElementById('board-rows'),
                winConditionInput: document.getElementById('win-condition'),
                enableDiagonalCheckbox: document.getElementById('enable-diagonal'),
                startGameBtn: window.innerWidth > 480
                    ? document.getElementById('start-game-btn')
                    : document.getElementById('start-game-btn-mobile'),

                // Controls
                pauseBtn: document.getElementById('pause-btn'),
                undoBtn: document.getElementById('undo-btn'),
                saveBtn: document.getElementById('save-btn'),
                loadGameInput: document.getElementById('load-game-input'),
                playAgainBtn: document.getElementById('play-again-btn'),
                closeModalBtn: document.getElementById('close-modal-btn'),

                // Audio elements
                enableSoundCheckbox: document.getElementById('enable-sound'),

                // Audio files
                discDropSound: document.getElementById('disc-drop-sound'),
                winSound: document.getElementById('win-sound'),
                computerWinSound: document.getElementById('computer-win-sound'),
                buttonClickSound: document.getElementById('button-click-sound'),
                columnHoverSound: document.getElementById('column-hover-sound'),
                errorSound: document.getElementById('error-sound')
            };

            // --- Game State ---
            let gameState = {};
            let currentFocusedColumn = 0;

            function getDefaultGameState() {
                return {
                    version: SAVE_FILE_VERSION,
                    board: [],
                    players: [],
                    currentPlayerIndex: 0,
                    gameOver: false,
                    isPaused: false,
                    winner: null,
                    winningCells: [],
                    moveHistory: [],
                    lastHintColumn: -1,
                    isInputEnabled: true,

                    settings: {
                        rows: 6,
                        cols: 7,
                        winCondition: 4,
                        enableDiagonal: true,
                        gameMode: 'classic',
                        timeLimit: 120,
                        turnTimeLimit: 0,
                        turnLimit: 15,
                        playerMode: 'vs_com',
                    },

                    timers: {
                        gameTimerId: null,
                        turnTimerId: null,
                        remainingGameTime: 120,
                        remainingTurnTime: 0,
                        gamePaused: false,
                        turnPaused: false,
                    },

                    turnsTaken: [],
                };
            }

            // --- Utility Functions ---
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            function validateSettings() {
                const rows = parseInt(elements.boardRowsInput.value);
                const cols = parseInt(elements.boardColsInput.value);
                const winCondition = parseInt(elements.winConditionInput.value);

                if (rows < 4 || rows > 15 || cols < 4 || cols > 15) {
                    alert('Board dimensions must be between 4 and 15');
                    return false;
                }

                if (winCondition < 3 || winCondition > Math.min(rows, cols)) {
                    alert(`Win condition must be between 3 and ${Math.min(rows, cols)} (the smallest board dimension)`);
                    return false;
                }
                return true;
            }

            function moveColumnFocus(direction) {
                currentFocusedColumn += direction;
                if (currentFocusedColumn < 0) currentFocusedColumn = gameState.settings.cols - 1;
                if (currentFocusedColumn >= gameState.settings.cols) currentFocusedColumn = 0;
                updateColumnHighlight();
            }

            function updateColumnHighlight() {
                document.querySelectorAll('.keyboard-focus').forEach(el => {
                    el.classList.remove('keyboard-focus');
                });
                for (let r = 0; r < gameState.settings.rows; r++) {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${currentFocusedColumn}']`);
                    if (cell) {
                        cell.classList.add('keyboard-focus');
                    }
                }
            }

            function getUniqueColors() {
                const playerCount = getPlayerCount();
                const colors = [];
                const usedColors = new Set();

                for (let i = 0; i < playerCount; i++) {
                    const input = document.getElementById(`player-${i + 1}-color`);
                    let color = input ? input.value : DEFAULT_PLAYER_COLORS[i];
                    let counter = 0;
                    while (usedColors.has(color) && counter < 10) {
                        const hue = Math.floor(Math.random() * 360);
                        color = `hsl(${hue}, 70%, 50%)`;
                        counter++;
                    }
                    if (counter >= 10) {
                        color = DEFAULT_PLAYER_COLORS[i % DEFAULT_PLAYER_COLORS.length];
                    }
                    colors.push(color);
                    usedColors.add(color);
                }
                return colors;
            }

            // --- Initialization ---
            function init() {
                gameState = getDefaultGameState();
                updatePlayerInputs();
                setupEventListeners();
                updateAudioSettings();
                startGame();
            }

            function setupEventListeners() {
                // Theme
                elements.lightModeBtn.addEventListener('click', () => {
                    document.body.className = 'light bg-[var(--background)] text-[var(--text)]';
                });
                elements.darkModeBtn.addEventListener('click', () => {
                    document.body.className = 'dark bg-[var(--background)] text-[var(--text)]';
                });

                // Settings
                elements.boardColorSelect.addEventListener('change', (e) => {
                    // Board background is now on #board-visual-layer
                    elements.boardVisualLayer.style.backgroundColor = e.target.value;
                });
                elements.gameModeSelect.addEventListener('change', updateGameModeOptionsVisibility);
                elements.playerModeSelect.addEventListener('change', updatePlayerInputs);
                elements.startGameBtn.addEventListener('click', startGame);

                // Validation
                const debouncedValidation = debounce(() => {
                    validateInputs();
                }, 300);
                [elements.boardRowsInput, elements.boardColsInput, elements.winConditionInput].forEach(input => {
                    input.addEventListener('input', debouncedValidation);
                });

                // Controls
                elements.pauseBtn.addEventListener('click', togglePause);
                elements.undoBtn.addEventListener('click', undoMove);
                elements.saveBtn.addEventListener('click', saveGame);
                elements.loadGameInput.addEventListener('change', loadGame);

                // Modal
                elements.playAgainBtn.addEventListener('click', () => {
                    hideModal();
                    startGame();
                });
                elements.closeModalBtn.addEventListener('click', () => {
                    hideModal();
                });

                // Keyboard support
                document.addEventListener('keydown', handleKeyboard);

                // Add resize handler with debouncing to avoid excessive recalculations
                const debouncedResize = debounce(() => {
                    if (gameState.board && gameState.board.length > 0) {
                        // Clear any falling discs to prevent positioning issues
                        elements.fallingDiscLayer.innerHTML = '';
                        renderBoard();
                    }
                }, 250);

                // Prevent accidental page refresh
                window.addEventListener('beforeunload', (e) => {
                    if (!gameState.gameOver && gameState.moveHistory.length > 0) {
                        e.preventDefault();
                        e.returnValue = '';
                    }
                });
                window.addEventListener('resize', debouncedResize);

                // Close color dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.color-dropdown')) {
                        document.querySelectorAll('.color-dropdown-content').forEach(content => {
                            content.classList.remove('show');
                        });
                    }
                });

                // Audio settings
                elements.enableSoundCheckbox.addEventListener('change', updateAudioSettings);
                // elements.volumeSlider.addEventListener('input', updateAudioSettings);

                // Button sound effects
                const buttonsWithSound = [
                    elements.startGameBtn, elements.pauseBtn, elements.undoBtn, elements.saveBtn, elements.playAgainBtn,
                    elements.closeModalBtn, elements.lightModeBtn, elements.darkModeBtn
                ];

                buttonsWithSound.forEach(button => {
                    if (button) {
                        button.addEventListener('click', () => {
                            playSound(elements.buttonClickSound, 0.3);
                        });
                    }
                });
            }

            function handleKeyboard(e) {
                // Don't handle keyboard events if user is interacting with form elements
                const activeElement = document.activeElement;
                const isFormElement = activeElement && (
                    activeElement.tagName === 'INPUT' ||
                    activeElement.tagName === 'SELECT' ||
                    activeElement.tagName === 'BUTTON' ||
                    activeElement.hasAttribute('contenteditable') ||
                    activeElement.closest('.color-dropdown') ||
                    activeElement.closest('aside') // Settings panel
                );

                // Handle spacebar (pause/resume) but not when interacting with form elements
                if (e.key === ' ') {
                    if (!isFormElement) {
                        e.preventDefault();
                        togglePause();
                    }
                    return;
                }

                // If game is over, paused, input disabled, or user is in form elements, prevent other actions
                if (gameState.gameOver || gameState.isPaused || !gameState.isInputEnabled || isFormElement) return;

                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return;

                if (e.key >= '1' && e.key <= '9') {
                    const col = parseInt(e.key) - 1;
                    if (col < gameState.settings.cols) makeMove(col);
                } else if (e.key === 'h' || e.key === 'H') {
                    showHint();
                } else if (e.key === 'u' || e.key === 'U') {
                    undoMove();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    moveColumnFocus(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    moveColumnFocus(1);
                } else if (e.key === 'ArrowDown' || e.key === 'Enter') {
                    e.preventDefault();
                    makeMove(currentFocusedColumn);
                }
            }

            function updateGameModeOptionsVisibility() {
                const mode = elements.gameModeSelect.value;
                elements.timedOptions.classList.toggle('hidden', mode !== 'timed');
                elements.fixedTurnOptions.classList.toggle('hidden', mode !== 'fixed_turn');
            }

            function updatePlayerInputs() {
                // Update player color and name inputs
                elements.playerColorsContainer.innerHTML = '';
                const playerCount = getPlayerCount();
                for (let i = 0; i < playerCount; i++) {
                    const playerType = getPlayerType(i);
                    const defaultName = playerType === 'Computer' ? 'Computer' : `Player ${i + 1}`;

                    // Combined label for both inputs
                    const label = document.createElement('label');
                    label.className = 'block font-medium mb-1';
                    label.textContent = playerType;

                    // Container for color and name inputs (flex row)
                    const inputContainer = document.createElement('div');
                    inputContainer.className = 'flex gap-2 mb-3';

                    // Color input dropdown
                    const colorDropdown = document.createElement('div');
                    colorDropdown.className = 'color-dropdown';
                    colorDropdown.id = `player-${i + 1}-color-dropdown`;

                    const currentColor = gameState.players && gameState.players[i] ?
                        gameState.players[i].color : DEFAULT_PLAYER_COLORS[i];

                    // Dropdown button
                    const dropdownButton = document.createElement('div');
                    dropdownButton.className = 'color-dropdown-button';
                    dropdownButton.style.backgroundColor = currentColor;
                    dropdownButton.setAttribute('tabindex', '0');
                    dropdownButton.setAttribute('role', 'button');
                    dropdownButton.setAttribute('aria-label', `Select color for ${getPlayerType(i)}`);

                    // Dropdown content
                    const dropdownContent = document.createElement('div');
                    dropdownContent.className = 'color-dropdown-content';

                    // Create color options
                    DEFAULT_PLAYER_COLORS.forEach(color => {
                        const colorOption = document.createElement('div');
                        colorOption.className = 'color-option';
                        colorOption.style.backgroundColor = color;
                        if (color === currentColor) {
                            colorOption.classList.add('selected');
                        }

                        colorOption.addEventListener('click', () => {
                            // Update button color
                            dropdownButton.style.backgroundColor = color;

                            // Update selected state
                            dropdownContent.querySelectorAll('.color-option').forEach(opt =>
                                opt.classList.remove('selected'));
                            colorOption.classList.add('selected');

                            // Update game state
                            if (gameState.players && gameState.players[i]) {
                                gameState.players[i].color = color;
                                renderBoard();
                                updateDisplay();
                                updateMoveHistory();
                            }

                            // Hide dropdown
                            dropdownContent.classList.remove('show');
                        });

                        dropdownContent.appendChild(colorOption);
                    });

                    // Toggle dropdown on button click
                    dropdownButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Hide other dropdowns
                        document.querySelectorAll('.color-dropdown-content').forEach(content => {
                            if (content !== dropdownContent) {
                                content.classList.remove('show');
                            }
                        });
                        dropdownContent.classList.toggle('show');
                    });

                    // Keyboard support
                    dropdownButton.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            dropdownButton.click();
                        }
                    });

                    colorDropdown.appendChild(dropdownButton);
                    colorDropdown.appendChild(dropdownContent);

                    // Name input
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.id = `player-${i + 1}-name`;
                    nameInput.className = 'flex-1 p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus';
                    nameInput.value = gameState.players && gameState.players[i] ?
                        gameState.players[i].name : defaultName;
                    nameInput.placeholder = defaultName;

                    // Add real-time color change functionality
                    colorDropdown.addEventListener('change', (e) => {
                        if (gameState.players && gameState.players[i]) {
                            gameState.players[i].color = e.target.value;
                            renderBoard();
                            updateDisplay();
                            updateMoveHistory();
                        }
                    });

                    // Add real-time name change functionality
                    nameInput.addEventListener('input', (e) => {
                        if (gameState.players && gameState.players[i]) {
                            gameState.players[i].name = e.target.value || defaultName;
                            updateDisplay();
                            updateMoveHistory();
                        }
                    });

                    // Append inputs to container
                    inputContainer.appendChild(colorDropdown);
                    inputContainer.appendChild(nameInput);

                    // Append to main container
                    // elements.playerColorsContainer.appendChild(label);
                    elements.playerColorsContainer.appendChild(inputContainer);
                }

                // Update AI settings
                updateAISettings();
            }

            function updateAISettings() {
                elements.aiSettingsContainer.innerHTML = '';
                if (elements.playerModeSelect.value === 'vs_com') {
                    elements.aiSettingsContainer.classList.remove('hidden');
                    const label = document.createElement('label');
                    label.className = 'block font-medium mb-1';
                    label.textContent = 'AI Difficulty';
                    const select = document.createElement('select');
                    select.id = 'ai-difficulty';
                    select.className = 'w-full p-2 rounded bg-white dark:bg-gray-700 border focus-visible:focus';
                    ['very easy', 'easy', 'medium', 'hard'].forEach(difficulty => {
                        const option = document.createElement('option');
                        option.value = difficulty;
                        option.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                        select.appendChild(option);
                    });
                    elements.aiSettingsContainer.appendChild(label);
                    elements.aiSettingsContainer.appendChild(select);
                } else {
                    elements.aiSettingsContainer.classList.add('hidden');
                }
            }

            function getPlayerCount() {
                const mode = elements.playerModeSelect.value;
                switch (mode) {
                    case 'vs_com':
                    case '2_player':
                        return 2;
                    case '3_player':
                        return 3;
                    case '4_player':
                        return 4;
                    default:
                        return 2;
                }
            }

            function getPlayerType(index) {
                if (elements.playerModeSelect.value === 'vs_com' && index === 1) {
                    return 'Computer';
                }
                return `Player ${index + 1}`;
            }

            function validateInputs() {
                const rows = parseInt(elements.boardRowsInput.value);
                const cols = parseInt(elements.boardColsInput.value);
                const winCondition = parseInt(elements.winConditionInput.value);
                if (winCondition > Math.min(rows, cols)) {
                    elements.winConditionInput.value = Math.min(rows, cols);
                }
            }

            // --- Audio Functions ---
            function playSound(audioElement, volume = null) {
                if (!elements.enableSoundCheckbox.checked) return;

                try {
                    audioElement.currentTime = 0;

                    // Use the provided volume or default to full volume
                    const volumeLevel = volume !== null ? volume : 1.0;
                    audioElement.volume = Math.max(0, Math.min(1, volumeLevel));

                    const playPromise = audioElement.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log('Audio play failed:', error);
                        });
                    }
                } catch (error) {
                    console.log('Audio error:', error);
                }
            }

            function updateAudioSettings() {
                const soundEnabled = elements.enableSoundCheckbox.checked;

                // Update all audio elements volume - explicitly target each one
                const volume = soundEnabled ? 1.0 : 0;

                // Set volume for each audio element directly
                if (elements.discDropSound) elements.discDropSound.volume = volume;
                if (elements.winSound) elements.winSound.volume = volume;
                if (elements.computerWinSound) elements.computerWinSound.volume = volume;
                if (elements.buttonClickSound) elements.buttonClickSound.volume = volume;
                if (elements.columnHoverSound) elements.columnHoverSound.volume = volume;
                if (elements.errorSound) elements.errorSound.volume = volume;
            }

            // --- Game Logic ---
            function startGame() {
                console.log('New Game Started');

                if (!validateSettings()) return;
                cleanupGame();
                gameState = getDefaultGameState();

                // Apply settings
                gameState.settings.rows = parseInt(elements.boardRowsInput.value);
                gameState.settings.cols = parseInt(elements.boardColsInput.value);
                gameState.settings.winCondition = parseInt(elements.winConditionInput.value);
                gameState.settings.enableDiagonal = elements.enableDiagonalCheckbox.checked;
                gameState.settings.gameMode = elements.gameModeSelect.value;
                gameState.settings.timeLimit = parseInt(elements.timeLimitSelect.value);
                gameState.settings.turnTimeLimit = parseInt(elements.turnTimeLimitSelect.value);
                gameState.settings.turnLimit = parseInt(elements.turnLimitInput.value);
                gameState.settings.playerMode = elements.playerModeSelect.value;

                // Initialize players
                const playerCount = getPlayerCount();
                const colors = getUniqueColors();
                gameState.players = [];
                gameState.turnsTaken = [];
                for (let i = 0; i < playerCount; i++) {
                    const isAI = elements.playerModeSelect.value === 'vs_com' && i === 1;

                    // Get custom name from input
                    const nameInput = document.getElementById(`player-${i + 1}-name`);
                    const playerName = nameInput ? nameInput.value.trim() || (isAI ? 'Computer' : `Player ${i + 1}`) : (isAI ? 'Computer' : `Player ${i + 1}`);

                    gameState.players.push({
                        id: i + 1,
                        name: playerName,
                        color: colors[i],
                        isAI: isAI,
                        difficulty: isAI ? document.getElementById('ai-difficulty')?.value || 'easy' : null,
                    });
                    gameState.turnsTaken.push(0);
                }


                // Initialize board
                gameState.board = Array(gameState.settings.rows).fill(null).map(() =>
                    Array(gameState.settings.cols).fill(0)
                );

                // Set initial board color on the visual layer
                elements.boardVisualLayer.style.backgroundColor = elements.boardColorSelect.value;

                // Setup timers
                if (gameState.settings.gameMode === 'timed') {
                    gameState.timers.remainingGameTime = gameState.settings.timeLimit;
                    gameState.timers.remainingTurnTime = gameState.settings.turnTimeLimit;
                }

                renderBoard(); // Call renderBoard after all settings are applied
                updateDisplay();
                elements.winnerModal.classList.add('hidden');
                elements.undoBtn.disabled = true;
                elements.historyList.innerHTML = '';

                if (gameState.settings.gameMode === 'timed') {
                    startGameTimer();
                }
                // nextTurn();
                currentFocusedColumn = Math.floor(gameState.settings.cols / 2);
                updateColumnHighlight();

                // Ensure listeners are set up for dynamic color changes
                // setupPlayerColorListeners();

                // LOGIC TO HANDLE INITIAL PLAYER'S TURN (especially if AI)
                const initialPlayer = gameState.players[gameState.currentPlayerIndex]; // Should be Player 1 (index 0)
                if (initialPlayer && initialPlayer.isAI) {
                    setInteractionState(false); // Disable input for AI's turn
                    setTimeout(() => aiMove(initialPlayer.difficulty), 1000); // Trigger AI move after a delay
                } else {
                    setInteractionState(true); // Enable input for human Player 1
                }
            }


            function cleanupGame() {
                clearTimers();
                // Clear any existing falling discs
                if (elements.fallingDiscLayer) {
                    elements.fallingDiscLayer.innerHTML = '';
                }
                // Reset timer states
                if (gameState && gameState.timers) {
                    gameState.timers.gamePaused = false;
                    gameState.timers.turnPaused = false;
                }
            }

            function renderBoard() {
                // Set dynamic aspect ratio
                const aspectRatio = `${gameState.settings.cols}/${gameState.settings.rows}`;
                elements.boardContainer.style.setProperty('--board-aspect-ratio', aspectRatio);
                elements.gameBoard.innerHTML = ''; // Clear interactive cells
                // No longer clearing discLayer, as discs are children of cells now

                elements.gameBoard.style.gridTemplateColumns = `repeat(${gameState.settings.cols}, 1fr)`;
                elements.gameBoard.style.gridTemplateRows = `repeat(${gameState.settings.rows}, 1fr)`;

                // Get computed styles for accurate measurements from the interactive grid
                const boardComputedStyle = window.getComputedStyle(elements.gameBoard);
                const boardPaddingLeft = parseFloat(boardComputedStyle.paddingLeft);
                const boardPaddingTop = parseFloat(boardComputedStyle.paddingTop);
                let gap = 12;
                if (window.innerWidth < 576) {
                    gap = 6;
                }

                // Calculate effective board content dimensions
                const boardContentWidth = elements.gameBoard.clientWidth - boardPaddingLeft - parseFloat(boardComputedStyle.paddingRight);
                const boardContentHeight = elements.gameBoard.clientHeight - boardPaddingTop - parseFloat(boardComputedStyle.paddingBottom);

                const cellWidth = (boardContentWidth - (gameState.settings.cols - 1) * gap) / gameState.settings.cols;
                const cellHeight = (boardContentHeight - (gameState.settings.rows - 1) * gap) / gameState.settings.rows;

                const discDiameter = (cellWidth * 0.9); // Diameter of the disc
                const holeRadius = discDiameter / 2; // Radius of the hole

                const maskGradients = [];
                // Start with a solid black background for the mask. This is the base that will be "cut out".
                maskGradients.push('linear-gradient(black, black)');

                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        // Calculate center of each hole relative to #game-board (which is also the coordinate system for boardVisualLayer)
                        const xCenter = boardPaddingLeft + c * (cellWidth + gap) + cellWidth / 2;
                        const yCenter = boardPaddingTop + r * (cellHeight + gap) + cellHeight / 2;

                        // For 'exclude', we want to subtract an opaque circle (black) from the base.
                        // So, the gradient should be black inside the hole, and transparent outside.
                        // Use hard stops for sharp edges.
                        maskGradients.push(`radial-gradient(circle ${holeRadius}px at ${xCenter}px ${yCenter}px, black ${holeRadius * 0.95}px, transparent ${holeRadius * 1}px)`);

                        // Create interactive cell (no visual, just for clicks/hover)
                        const cell = document.createElement('div');
                        cell.className = 'cell aspect-square flex justify-center items-center';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `Row ${r + 1}, Column ${c + 1}`);

                        // Add click/hover listeners to top row cells
                        if (r === 0) {
                            cell.addEventListener('click', () => handleCellClick(c));
                            cell.addEventListener('mouseenter', () => highlightColumn(c, true));
                            cell.addEventListener('mouseleave', () => highlightColumn(c, false));
                            cell.tabIndex = 0;
                            cell.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter' || e.key === ' ') {
                                    e.preventDefault();
                                    handleCellClick(c);
                                }
                            });
                        }
                        elements.gameBoard.appendChild(cell);

                        // If a disc exists, create it and append to the cell
                        const playerOwner = gameState.board[r][c];
                        if (playerOwner > 0) {
                            const disc = document.createElement('div');
                            disc.className = 'disc';
                            disc.style.backgroundColor = gameState.players[playerOwner - 1].color;
                            disc.setAttribute('aria-label', `${gameState.players[playerOwner - 1].name} disc`);
                            cell.appendChild(disc);
                        }
                    }
                }

                // Apply the mask after the container has resized
                requestAnimationFrame(() => {
                    const maskValue = maskGradients.join(', ');
                    elements.boardVisualLayer.style.maskImage = maskValue;
                    elements.boardVisualLayer.style.webkitMaskImage = maskValue;
                });

                highlightWinningCells();
            }

            function highlightColumn(col, highlight) {
                if (gameState.gameOver || gameState.isPaused) return; // No highlight if game is over or paused
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return; // No highlight during AI turn

                for (let r = 0; r < gameState.settings.rows; r++) {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${col}']`);
                    if (cell) {
                        if (highlight && getNextAvailableRow(col) !== -1) {
                            cell.classList.add('column-highlight'); // Add highlight if column is valid for a move
                        } else {
                            cell.classList.remove('column-highlight'); // Remove highlight
                        }
                    }
                }

                // Play hover sound if highlighting and not already played recently
                if (highlight && getNextAvailableRow(col) !== -1) {
                    const cell = elements.gameBoard.querySelector(`[data-row='0'][data-col='${col}']`); // Get top cell for sound
                    if (cell && !cell.dataset.hoverSoundPlayed) {
                        playSound(elements.columnHoverSound, 0.2);
                        cell.dataset.hoverSoundPlayed = 'true';
                        // Prevent sound from playing too frequently
                        setTimeout(() => {
                            delete cell.dataset.hoverSoundPlayed;
                        }, 200);
                    }
                }
            }

            function highlightWinningCells() {
                gameState.winningCells.forEach(([r, c]) => {
                    const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${c}']`);
                    const disc = cell?.querySelector('.disc'); // Find the disc within the cell
                    if (disc) {
                        disc.classList.add('winning-disc');
                    }
                });
            }

            function handleCellClick(col) {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) return;
                makeMove(col);
            }

            function makeMove(col) {
                if (gameState.gameOver) return;
                const row = getNextAvailableRow(col);
                if (row === -1) {
                    playSound(elements.errorSound, 0.4);
                    return;
                }

                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                setInteractionState(false);

                gameState.moveHistory.push({
                    player: gameState.currentPlayerIndex,
                    col: col,
                    row: row,
                    boardState: gameState.board.map(row => [...row])
                });

                animateDiscDrop(col, row, currentPlayer.color, () => {
                    gameState.board[row][col] = currentPlayer.id;
                    updateMoveHistory();
                    elements.undoBtn.disabled = false;

                    const winner = checkWin(row, col);
                    if (winner) {
                        endGame(`${winner.name} wins!`, winner);
                        return;
                    }

                    if (isBoardFull()) {
                        endGame("It's a draw!");
                        return;
                    }

                    if (gameState.settings.gameMode === 'fixed_turn' &&
                        (gameState.turnsTaken[gameState.currentPlayerIndex] + 1) >= gameState.settings.turnLimit) {

                        // Check if this was the last player's last turn
                        let allPlayersFinished = true;
                        for (let i = 0; i < gameState.players.length; i++) {
                            const turnsForPlayer = i === gameState.currentPlayerIndex ?
                                gameState.turnsTaken[i] + 1 : gameState.turnsTaken[i];
                            if (turnsForPlayer < gameState.settings.turnLimit) {
                                allPlayersFinished = false;
                                break;
                            }
                        }

                        if (allPlayersFinished) {
                            const result = determineFixedTurnWinner();
                            endGame(result.message, result.winner);
                            return;
                        }
                    }

                    nextTurn();
                });
            }

            function animateDiscDrop(col, targetRow, color, callback) {
                // Get the falling disc layer's dimensions instead of gameBoard
                const fallingLayerRect = elements.fallingDiscLayer.getBoundingClientRect();
                const gameBoardRect = elements.gameBoard.getBoundingClientRect();
                const offsetLeft = gameBoardRect.left - fallingLayerRect.left;

                // Get board's computed styles for accurate measurements
                const boardComputedStyle = window.getComputedStyle(elements.gameBoard);
                const boardPaddingLeft = parseFloat(boardComputedStyle.paddingLeft);
                const boardPaddingRight = parseFloat(boardComputedStyle.paddingRight);
                let gap = 12;
                if (window.innerWidth < 480) {
                    gap = 6;
                }

                // Calculate effective board content width
                const boardContentWidth = elements.gameBoard.clientWidth - boardPaddingLeft - boardPaddingRight;
                // Calculate individual cell width
                const cellWidth = (boardContentWidth - (gameState.settings.cols - 1) * gap) / gameState.settings.cols;

                // Calculate disc's horizontal center relative to board's content area
                const discLeft = offsetLeft + boardPaddingLeft + col * (cellWidth + gap) + cellWidth / 2;
                // Calculate disc size (90% of cell + 6px)
                const discSize = (cellWidth * 0.9) + 6;

                // Create falling disc element
                const fallingDisc = document.createElement('div');
                fallingDisc.className = 'falling-disc disc';
                fallingDisc.style.backgroundColor = color;
                fallingDisc.style.width = `${discSize}px`;
                fallingDisc.style.height = `${discSize}px`;
                fallingDisc.style.willChange = 'transform'; // GPU optimization

                // Set disc's initial position (above board, horizontally centered)
                fallingDisc.style.left = `${discLeft}px`;
                fallingDisc.style.top = '0px'; // Start at top of container
                fallingDisc.style.transform = `translate(-50%, -${discSize * 2}px)`; // Move above board using transform

                // IMPORTANT: Append to the falling disc layer
                elements.fallingDiscLayer.appendChild(fallingDisc);

                // Calculate the offset between the falling layer and game board
                const offsetTop = gameBoardRect.top - fallingLayerRect.top;

                const boardPaddingTop = parseFloat(boardComputedStyle.paddingTop);
                const boardPaddingBottom = parseFloat(boardComputedStyle.paddingBottom);
                const boardContentHeight = elements.gameBoard.clientHeight - boardPaddingTop - boardPaddingBottom;
                const cellHeight = (boardContentHeight - (gameState.settings.rows - 1) * gap) / gameState.settings.rows;

                // Calculate target vertical center relative to the falling disc layer
                let targetTop = boardPaddingTop + targetRow * (cellHeight + gap) + gap / 2;
                
                if (window.innerWidth < 480) {
                    targetTop = boardPaddingTop + targetRow * (cellHeight + gap);
                }

                // Calculate the EXACT final cell center position
                const finalCellCenterTop = offsetTop + boardPaddingTop + targetRow * (cellHeight + gap) + cellHeight / 2;

                // Calculate fall time based on distance - more consistent timing
                const fallDistance = targetTop + (discSize * 2); // Add the initial offset
                const fallTime = Math.min(600, Math.max(300, Math.abs(fallDistance) * 1.0));

                // Use transform for better performance and add bounce effect with cubic-bezier
                fallingDisc.style.transition = `transform ${fallTime}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;

                fallingDisc.style.boxShadow = '0 8px 20px rgba(0,0,0,0.5), inset 0 0px 8px rgba(255, 255, 255, 0.3)';

                // Start fall animation
                requestAnimationFrame(() => {
                    fallingDisc.style.transform = `translate(-50%, ${targetTop}px)`;
                });

                // Add bounce effect and smooth settling
                setTimeout(() => {
                    playSound(elements.discDropSound, 0.6);

                    // Quick bounce up
                    fallingDisc.style.transition = 'transform 120ms ease-out';
                    fallingDisc.style.transform = `translate(-50%, ${targetTop - (targetTop * 0.005)}px)`;

                    setTimeout(() => {
                        // First settle to bounce position
                        fallingDisc.style.transition = 'transform 80ms ease-in';
                        fallingDisc.style.transform = `translate(-50%, ${targetTop}px)`;

                        setTimeout(() => {
                            // Update shadow before final settling
                            fallingDisc.style.boxShadow = 'inset 0 0px 8px rgba(255, 255, 255, 0.5), inset 0px 0px 15px rgba(0, 0, 0, 0.3)';

                            // SMOOTH SETTLING ANIMATION - move to exact cell center
                            fallingDisc.style.transition = 'transform 200ms ease-out, opacity 150ms ease-out';
                            fallingDisc.style.transform = `translate(-50%, calc(${finalCellCenterTop}px - 50% - 0px))`;


                            setTimeout(() => {
                                // Fade out the falling disc while the real disc appears
                                fallingDisc.style.opacity = '0';

                                // Call the callback to place the real disc
                                callback();

                                setTimeout(() => {
                                    // Cleanup after fade completes
                                    fallingDisc.style.willChange = 'auto';
                                    fallingDisc.remove();
                                }, 150);
                            }, 200);
                        }, 80);
                    }, 120);
                }, fallTime);
            }

            function setInteractionState(enabled) {
                gameState.isInputEnabled = enabled;
                elements.gameBoard.style.pointerEvents = enabled ? 'auto' : 'none';
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.tabIndex = enabled ? 0 : -1;
                });
            }

            function getNextAvailableRow(col) {
                for (let r = gameState.settings.rows - 1; r >= 0; r--) {
                    if (gameState.board[r][col] === 0) {
                        return r;
                    }
                }
                return -1;
            }

            function isBoardFull() {
                return gameState.board[0].every(cell => cell !== 0);
            }

            function checkWin(r, c) {
                const playerId = gameState.board[r][c];
                const winLength = gameState.settings.winCondition;
                const directions = [
                    [0, 1], // horizontal
                    [1, 0], // vertical
                    [1, 1], // diagonal /
                    [1, -1] // diagonal \
                ];

                for (const [dr, dc] of directions) {
                    if (!gameState.settings.enableDiagonal && (dr === 1 && dc !== 0)) continue;
                    const cells = [];
                    for (let dir = -1; dir <= 1; dir += 2) {
                        for (let i = 1; i < winLength; i++) {
                            const nr = r + dr * i * dir;
                            const nc = c + dc * i * dir;
                            if (nr >= 0 && nr < gameState.settings.rows &&
                                nc >= 0 && nc < gameState.settings.cols &&
                                gameState.board[nr][nc] === playerId) {
                                cells.push([nr, nc]);
                            } else {
                                break;
                            }
                        }
                    }
                    cells.push([r, c]);
                    if (cells.length >= winLength) {
                        gameState.winningCells = cells.slice(0, winLength);
                        return gameState.players[playerId - 1];
                    }
                }
                return null;
            }

            function checkFixedTurnEnd() {
                return gameState.turnsTaken.every(turns => turns >= gameState.settings.turnLimit);
            }

            function determineFixedTurnWinner() {
                const discCounts = Array(gameState.players.length).fill(0);
                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        if (gameState.board[r][c] > 0) {
                            discCounts[gameState.board[r][c] - 1]++;
                        }
                    }
                }
                const maxDiscs = Math.max(...discCounts);
                const winners = gameState.players.filter((p, i) => discCounts[i] === maxDiscs);
                if (winners.length > 1) {
                    return {
                        message: "It's a draw!",
                        winner: null
                    };
                } else {
                    return {
                        message: `${winners[0].name} wins with ${maxDiscs} discs!`,
                        winner: winners[0]
                    };
                }
            }

            function nextTurn() {
                gameState.turnsTaken[gameState.currentPlayerIndex]++;

                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                gameState.lastHintColumn = -1;

                // Reset and start turn timer if applicable for timed modes
                if (gameState.settings.gameMode === 'timed' && gameState.settings.turnTimeLimit > 0) {
                    resetTurnTimer(); // properly resets the time
                    startTurnTimer(); // checks for AI players
                }

                const currentPlayer = gameState.players[gameState.currentPlayerIndex];

                if (!gameState.gameOver) {
                    if (currentPlayer.isAI) {
                        setInteractionState(false);
                        setTimeout(() => aiMove(currentPlayer.difficulty), 1000);
                    } else {
                        setInteractionState(true);
                    }
                } else {
                    setInteractionState(true);
                }

                updateDisplay();
            }


            function endGame(message, winner = null) {
                // Play appropriate sound
                if (winner) {
                    if (winner.isAI) {
                        playSound(elements.computerWinSound, 0.8);
                    } else {
                        playSound(elements.winSound, 0.8);
                    }
                } else {
                    playSound(elements.buttonClickSound, 0.5);
                }

                gameState.gameOver = true;
                gameState.gameOverMessage = message;
                gameState.winner = winner;
                clearTimers();

                setInteractionState(true);

                // Show the modal
                elements.winnerMessage.textContent = message;
                showModal();
                updateDisplay();
                console.log(elements.winnerMessage.textContent);
            }

            function showModal() {


                elements.winnerModal.classList.remove('hidden');

                // Focus the first button
                elements.playAgainBtn.focus();

                // Add escape key listener
                document.addEventListener('keydown', handleModalKeydown);

                // Store the previously focused element to restore later
                elements.winnerModal.previouslyFocused = document.activeElement;
            }

            function hideModal() {
                elements.winnerModal.classList.add('hidden');

                // Remove escape key listener
                document.removeEventListener('keydown', handleModalKeydown);

                // Clean up any leftover visual states that might interfere with rendering
                document.querySelectorAll('.column-highlight').forEach(el => {
                    el.classList.remove('column-highlight');
                });
                document.querySelectorAll('.hint-highlight').forEach(el => {
                    el.classList.remove('hint-highlight');
                });

                // CRITICAL: Recalculate mask after modal closes to fix layer alignment
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // Double RAF ensures layout is fully settled after modal removal
                        if (gameState.board && gameState.board.length > 0) {
                            // Force a complete re-render to recalculate mask coordinates
                            renderBoard();
                        }
                    });
                });

                // Restore focus to previously focused element
                if (elements.winnerModal.previouslyFocused) {
                    elements.winnerModal.previouslyFocused.focus();
                    // Clear the reference
                    elements.winnerModal.previouslyFocused = null;
                }
            }

            function handleModalKeydown(e) {
                if (e.key === 'Escape') {
                    hideModal();
                }

                // Simple focus trapping
                if (e.key === 'Tab') {
                    const focusableElements = elements.winnerModal.querySelectorAll('button');
                    const firstElement = focusableElements[0];
                    const lastElement = focusableElements[focusableElements.length - 1];

                    if (e.shiftKey && document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    } else if (!e.shiftKey && document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }

            function updateDisplay() {
                updateStatus();
                updateTimerDisplay();
            }

            function updateStatus() {
                if (gameState.gameOver) {
                    // If the game is over, display the game over message.s.
                    elements.statusMessage.textContent = gameState.winner ?
                        `Game Over - ${gameState.winner.name} wins!` : 'Game Over - Draw!';
                    return; // Exit the function as game is over.
                }

                if (gameState.isPaused) {
                    // If the game is paused, display "Game Paused" without player info.
                    elements.statusMessage.textContent = 'Game Paused';
                } else {
                    // If the game is not paused and not over, display the current player's turn.
                    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                    if (currentPlayer) {
                        let statusText = `${currentPlayer.name}'s Turn`;
                        if (gameState.settings.gameMode === 'fixed_turn') {
                            statusText += ` (${gameState.turnsTaken[gameState.currentPlayerIndex] + 1}/${gameState.settings.turnLimit})`;
                        }
                        // Use innerHTML to include the colored circle for the current player.
                        elements.statusMessage.innerHTML = `
                <span class="inline-block w-5 h-5 rounded-full mr-2"
                      style="background-color: ${currentPlayer.color};"
                      aria-hidden="true"></span>
                ${statusText}
            `;
                    } else {
                        // Fallback if currentPlayer is somehow not defined (shouldn't happen in normal play).
                        elements.statusMessage.textContent = 'Starting Game...';
                    }
                }
            }

            function updateTimerDisplay() {
                if (gameState.settings.gameMode !== 'timed') {
                    elements.timerDisplay.textContent = '';
                    return;
                }
                const gameMinutes = Math.floor(gameState.timers.remainingGameTime / 60);
                const gameSeconds = gameState.timers.remainingGameTime % 60;
                let display = `Game: ${gameMinutes}:${gameSeconds.toString().padStart(2, '0')}`;
                if (gameState.settings.turnTimeLimit > 0) {
                    display += ` | Turn: ${gameState.timers.remainingTurnTime}s`;
                }
                elements.timerDisplay.textContent = display;
            }

            function updateMoveHistory() {
                const history = gameState.moveHistory.slice(-10);
                elements.historyList.innerHTML = history.map((move, index) => {
                    const moveNumber = gameState.moveHistory.length - history.length + index + 1;
                    const player = gameState.players[move.player];
                    return `<div class="mb-1">
                        <span style="color: ${player.color};">●</span>
                        Move ${moveNumber}: ${player.name} → Column ${move.col + 1}
                    </div>`;
                }).join('');

                requestAnimationFrame(() => {
                    renderBoard();
                });
            }

            // --- Timer Functions ---
            function clearTimers() {
                if (gameState && gameState.timers) {
                    if (gameState.timers.gameTimerId) {
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                    }
                    if (gameState.timers.turnTimerId) {
                        clearInterval(gameState.timers.turnTimerId);
                        gameState.timers.turnTimerId = null;
                    }
                }
            }

            function startGameTimer() {
                // Clear any existing interval before setting a new one to prevent duplicates
                if (gameState.timers.gameTimerId) {
                    clearInterval(gameState.timers.gameTimerId);
                }

                gameState.timers.gameTimerId = setInterval(() => {
                    if (gameState.gameOver || gameState.isPaused) {
                        return;
                    }

                    gameState.timers.remainingGameTime--;
                    updateTimerDisplay();

                    if (gameState.timers.remainingGameTime <= 0) {
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                        endGame("Time's up! It's a draw!");
                    }
                }, 1000);
            }

            function startTurnTimer() {
                // Don't start turn timer for AI players
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer && currentPlayer.isAI) {
                    return;
                }

                // Clear any existing interval before setting a new one
                if (gameState.timers.turnTimerId) {
                    clearInterval(gameState.timers.turnTimerId);
                }

                // Only start timer if turn time limit is set
                if (gameState.settings.turnTimeLimit <= 0) {
                    return;
                }

                gameState.timers.turnTimerId = setInterval(() => {
                    if (gameState.gameOver || gameState.isPaused) {
                        clearInterval(gameState.timers.turnTimerId);
                        gameState.timers.turnTimerId = null;
                        return;
                    }

                    gameState.timers.remainingTurnTime--;
                    updateTimerDisplay();

                    if (gameState.timers.remainingTurnTime <= 0) {
                        clearInterval(gameState.timers.turnTimerId);
                        gameState.timers.turnTimerId = null;
                        playSound(elements.errorSound, 0.4);
                        nextTurn();
                    }
                }, 1000);
            }


            function resetTurnTimer() {
                if (gameState.timers.turnTimerId) {
                    clearInterval(gameState.timers.turnTimerId);
                    gameState.timers.turnTimerId = null;
                }
                gameState.timers.remainingTurnTime = gameState.settings.turnTimeLimit;
            }

            // --- AI Functions ---
            function aiMove(difficulty) {
                if (gameState.gameOver) return;
                let col;
                switch (difficulty) {
                    case 'very easy':
                        col = getVeryEasyAIMove();
                        break;
                    case 'easy':
                        col = getEasyAIMove();
                        break;
                    case 'medium':
                        col = getMediumAIMove();
                        break;
                    case 'hard':
                        col = getHardAIMove();
                        break;
                    default:
                        col = getMediumAIMove();
                }
                if (col !== -1) {
                    makeMove(col);
                }
            }

            function getValidMoves() {
                const validCols = [];
                for (let c = 0; c < gameState.settings.cols; c++) {
                    if (getNextAvailableRow(c) !== -1) {
                        validCols.push(c);
                    }
                }
                return validCols;
            }

            /**
            * Very Easy AI: Random Moves without any strategy
            */
            function getVeryEasyAIMove() {
                console.log('AI Level 1 Move Made');
                const validCols = getValidMoves();
                return validCols.length > 0 ?
                    validCols[Math.floor(Math.random() * validCols.length)] : -1;
            }

            /**
            * Easy AI: Uses strategic heuristics with threat detection and positional play.
            * Doesn't consider multiple threats
            */
            function getEasyAIMove() {
                console.log('AI Level 2 Move Made');
                const validCols = getValidMoves();
                if (validCols.length === 0) return -1;

                if (Math.random() < 0.1) { // 10% chance of random move
                    return validCols[Math.floor(Math.random() * validCols.length)];
                }

                const aiId = gameState.players[gameState.currentPlayerIndex].id;
                const opponentId = gameState.players[(gameState.currentPlayerIndex + 1) % gameState.players.length].id;

                // 1. Check for immediate winning moves
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = aiId;
                    if (checkWin(row, col)) {
                        gameState.board[row][col] = 0;
                        return col;
                    }
                    gameState.board[row][col] = 0;
                }

                // 2. Block opponent's winning moves
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = opponentId;
                    if (checkWin(row, col)) {
                        gameState.board[row][col] = 0;
                        return col;
                    }
                    gameState.board[row][col] = 0;
                }

                // 3. Strategic positioning with limited lookahead
                let bestScore = -Infinity;
                let bestCol = validCols[0];

                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = aiId;

                    // Combine immediate board evaluation with shallow minimax
                    let score = evaluateBoardAdvanced(aiId) * 2;
                    score += minimax(2, false, -Infinity, Infinity, gameState.currentPlayerIndex);

                    gameState.board[row][col] = 0;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCol = col;
                    }
                }

                return bestCol;
            }

            /**
             * Medium AI: Uses strategic heuristics with threat detection and positional play
             * Considers multiple threats
             */
            function getMediumAIMove() {
                console.log('AI Level 3 Move Made');
                const validCols = getValidMoves();
                if (validCols.length === 0) return -1;

                // if (Math.random() < 0.1) { // 10% chance of random move
                //     return validCols[Math.floor(Math.random() * validCols.length)];
                // }

                const aiId = gameState.players[gameState.currentPlayerIndex].id;
                const opponentId = gameState.players[(gameState.currentPlayerIndex + 1) % gameState.players.length].id;

                // 1. Check for immediate winning moves
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = aiId;
                    if (checkWin(row, col)) {
                        gameState.board[row][col] = 0;
                        return col;
                    }
                    gameState.board[row][col] = 0;
                }

                // 2. Block opponent's winning moves
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = opponentId;
                    if (checkWin(row, col)) {
                        gameState.board[row][col] = 0;
                        return col;
                    }
                    gameState.board[row][col] = 0;
                }

                // // 3. Look for fork opportunities (creating multiple threats)
                // const forkMove = findForkOpportunity(aiId, validCols);
                // if (forkMove !== -1) return forkMove;

                // 4. Block opponent's fork opportunities
                const blockForkMove = findForkOpportunity(opponentId, validCols);
                if (blockForkMove !== -1) return blockForkMove;

                // 5. Strategic positioning with limited lookahead
                let bestScore = -Infinity;
                let bestCol = validCols[0];

                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = aiId;

                    // Combine immediate board evaluation with shallow minimax
                    let score = evaluateBoardAdvanced(aiId) * 2;
                    score += minimax(3, false, -Infinity, Infinity, gameState.currentPlayerIndex);

                    gameState.board[row][col] = 0;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCol = col;
                    }
                }

                return bestCol;
            }

            /**
             * Hard AI: Uses deep minimax with alpha-beta pruning, move ordering, and advanced heuristics
             */
            function getHardAIMove() {
                console.log('AI Level 4 Move Made');
                const validCols = getValidMoves();
                if (validCols.length === 0) return -1;

                const aiId = gameState.players[gameState.currentPlayerIndex].id;
                const opponentId = gameState.players[(gameState.currentPlayerIndex + 1) % gameState.players.length].id;

                // Immediate tactical checks (same as medium but faster)
                const immediateWin = findImmediateWin(aiId, validCols);
                if (immediateWin !== -1) return immediateWin;

                const blockWin = findImmediateWin(opponentId, validCols);
                if (blockWin !== -1) return blockWin;

                // Order moves by their strategic value for better alpha-beta pruning
                const orderedMoves = orderMoves(validCols, aiId);

                let bestScore = -Infinity;
                let bestCol = orderedMoves[0];

                // Use iterative deepening for better time management
                const maxDepth = Math.min(4, 42 - getCurrentMoveCount()); // Adaptive depth

                for (const col of orderedMoves) {
                    const row = getNextAvailableRow(col);
                    if (row === -1) continue;

                    gameState.board[row][col] = aiId;

                    // Use advanced minimax with improved pruning
                    const score = minimaxAdvanced(maxDepth, false, -Infinity, Infinity,
                        gameState.currentPlayerIndex, col);

                    gameState.board[row][col] = 0;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCol = col;
                    }
                }

                return bestCol;
            }

            /**
             * Advanced minimax with enhanced pruning and threat detection
             */
            function minimaxAdvanced(depth, isMaximizing, alpha, beta, originalAI, lastMove = -1) {
                const winnerInfo = checkForTerminalState();

                if (depth === 0 || winnerInfo.isTerminal) {
                    if (winnerInfo.isTerminal) {
                        if (winnerInfo.winner === null) return 0;
                        if (winnerInfo.winner === originalAI) return 100000 + depth;
                        return -100000 - depth;
                    }
                    return evaluateBoardAdvanced(gameState.players[originalAI].id);
                }

                const validCols = getValidMoves();
                const currentPlayerId = gameState.players[gameState.currentPlayerIndex].id;

                // Enhanced move ordering
                const orderedCols = orderMoves(validCols, currentPlayerId, lastMove);

                if (isMaximizing) {
                    let maxScore = -Infinity;
                    for (const col of orderedCols) {
                        const row = getNextAvailableRow(col);
                        gameState.board[row][col] = currentPlayerId;

                        const nextPlayer = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                        const originalPlayer = gameState.currentPlayerIndex;
                        gameState.currentPlayerIndex = nextPlayer;

                        const score = minimaxAdvanced(depth - 1, originalAI === nextPlayer,
                            alpha, beta, originalAI, col);

                        gameState.currentPlayerIndex = originalPlayer;
                        gameState.board[row][col] = 0;

                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break; // Alpha-beta cutoff
                    }
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    for (const col of orderedCols) {
                        const row = getNextAvailableRow(col);
                        gameState.board[row][col] = currentPlayerId;

                        const nextPlayer = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                        const originalPlayer = gameState.currentPlayerIndex;
                        gameState.currentPlayerIndex = nextPlayer;

                        const score = minimaxAdvanced(depth - 1, originalAI === nextPlayer,
                            alpha, beta, originalAI, col);

                        gameState.currentPlayerIndex = originalPlayer;
                        gameState.board[row][col] = 0;

                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break; // Alpha-beta cutoff
                    }
                    return minScore;
                }
            }

            /**
             * Finds immediate winning moves
             */
            function findImmediateWin(playerId, validCols) {
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = playerId;
                    if (checkWin(row, col)) {
                        gameState.board[row][col] = 0;
                        return col;
                    }
                    gameState.board[row][col] = 0;
                }
                return -1;
            }

            /**
             * Finds fork opportunities (moves that create multiple winning threats)
             */
            function findForkOpportunity(playerId, validCols) {
                for (const col of validCols) {
                    const row = getNextAvailableRow(col);
                    gameState.board[row][col] = playerId;

                    let threats = 0;
                    for (const testCol of validCols) {
                        if (testCol === col) continue;
                        const testRow = getNextAvailableRow(testCol);
                        if (testRow === -1) continue;

                        gameState.board[testRow][testCol] = playerId;
                        if (checkWin(testRow, testCol)) {
                            threats++;
                        }
                        gameState.board[testRow][testCol] = 0;
                    }

                    gameState.board[row][col] = 0;

                    if (threats >= 2) return col; // Fork found
                }
                return -1;
            }

            /**
             * Orders moves for better alpha-beta pruning efficiency
             */
            function orderMoves(validCols, playerId, lastMove = -1) {
                const cols = gameState.settings.cols;
                const center = Math.floor(cols / 2);

                return validCols.sort((a, b) => {
                    let scoreA = 0, scoreB = 0;

                    // Prioritize center columns
                    scoreA += Math.max(0, 3 - Math.abs(a - center));
                    scoreB += Math.max(0, 3 - Math.abs(b - center));

                    // Prioritize columns adjacent to last move
                    if (lastMove !== -1) {
                        scoreA += Math.max(0, 2 - Math.abs(a - lastMove));
                        scoreB += Math.max(0, 2 - Math.abs(b - lastMove));
                    }

                    // Quick evaluation of move quality
                    const rowA = getNextAvailableRow(a);
                    const rowB = getNextAvailableRow(b);

                    if (rowA !== -1) {
                        gameState.board[rowA][a] = playerId;
                        scoreA += quickEvaluatePosition(rowA, a, playerId);
                        gameState.board[rowA][a] = 0;
                    }

                    if (rowB !== -1) {
                        gameState.board[rowB][b] = playerId;
                        scoreB += quickEvaluatePosition(rowB, b, playerId);
                        gameState.board[rowB][b] = 0;
                    }

                    return scoreB - scoreA; // Higher scores first
                });
            }

            /**
             * Quick position evaluation for move ordering
             */
            function quickEvaluatePosition(row, col, playerId) {
                let score = 0;
                const winCondition = gameState.settings.winCondition;

                // Check horizontal potential
                let left = 0, right = 0;
                for (let c = col - 1; c >= 0 && gameState.board[row][c] === playerId; c--) left++;
                for (let c = col + 1; c < gameState.settings.cols && gameState.board[row][c] === playerId; c++) right++;
                if (left + right + 1 >= winCondition) score += 50;

                // Check vertical potential
                let down = 0;
                for (let r = row + 1; r < gameState.settings.rows && gameState.board[r][col] === playerId; r++) down++;
                if (down + 1 >= winCondition) score += 50;

                return score;
            }

            /**
             * Get current number of moves played
             */
            function getCurrentMoveCount() {
                let count = 0;
                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        if (gameState.board[r][c] !== 0) count++;
                    }
                }
                return count;
            }

            /**
             * Enhanced board evaluation with sophisticated heuristics
             */
            function evaluateBoardAdvanced(aiId) {
                let score = 0;
                const rows = gameState.settings.rows;
                const cols = gameState.settings.cols;
                const winCondition = gameState.settings.winCondition;

                // Enhanced center column preference with position weighting
                const centerCol = Math.floor(cols / 2);
                for (let r = 0; r < rows; r++) {
                    if (gameState.board[r][centerCol] === aiId) {
                        score += 4 + (rows - r); // Higher pieces worth more
                    }
                }

                // Evaluate all possible windows with enhanced scoring
                score += evaluateAllWindows(aiId);

                // Add connectivity bonus (pieces next to each other)
                score += evaluateConnectivity(aiId);

                // Penalize isolated pieces
                score -= evaluateIsolation(aiId) * 2;

                // Add positional advantages
                score += evaluatePositionalAdvantages(aiId);

                return score;
            }

            /**
             * Enhanced window evaluation with better threat detection
             */
            function evaluateWindowAdvanced(window, aiId) {
                const winCondition = gameState.settings.winCondition;
                let aiCount = 0;
                let opponentCount = 0;
                let emptyCount = 0;

                for (const piece of window) {
                    if (piece === aiId) {
                        aiCount++;
                    } else if (piece === 0) {
                        emptyCount++;
                    } else {
                        opponentCount++;
                    }
                }

                if (aiCount > 0 && opponentCount > 0) return 0;

                // Enhanced scoring system
                if (aiCount === winCondition - 1 && emptyCount === 1) return 1000;
                if (aiCount === winCondition - 2 && emptyCount === 2) return 100;
                if (aiCount === winCondition - 3 && emptyCount === 3) return 10;
                if (aiCount > 0 && emptyCount === winCondition - aiCount) return aiCount * 2;

                if (opponentCount === winCondition - 1 && emptyCount === 1) return -800;
                if (opponentCount === winCondition - 2 && emptyCount === 2) return -80;
                if (opponentCount === winCondition - 3 && emptyCount === 3) return -8;

                return 0;
            }

            /**
             * Evaluates all possible windows on the board
             */
            function evaluateAllWindows(aiId) {
                let score = 0;
                const rows = gameState.settings.rows;
                const cols = gameState.settings.cols;
                const winCondition = gameState.settings.winCondition;

                // Horizontal windows
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c <= cols - winCondition; c++) {
                        const window = [];
                        for (let i = 0; i < winCondition; i++) {
                            window.push(gameState.board[r][c + i]);
                        }
                        score += evaluateWindowAdvanced(window, aiId);
                    }
                }

                // Vertical windows
                for (let c = 0; c < cols; c++) {
                    for (let r = 0; r <= rows - winCondition; r++) {
                        const window = [];
                        for (let i = 0; i < winCondition; i++) {
                            window.push(gameState.board[r + i][c]);
                        }
                        score += evaluateWindowAdvanced(window, aiId);
                    }
                }

                // Diagonal windows (both directions)
                for (let r = 0; r <= rows - winCondition; r++) {
                    for (let c = 0; c <= cols - winCondition; c++) {
                        const window1 = [], window2 = [];
                        for (let i = 0; i < winCondition; i++) {
                            window1.push(gameState.board[r + i][c + i]);
                            window2.push(gameState.board[r + winCondition - 1 - i][c + i]);
                        }
                        score += evaluateWindowAdvanced(window1, aiId);
                        score += evaluateWindowAdvanced(window2, aiId);
                    }
                }

                return score;
            }

            /**
             * Evaluates piece connectivity (bonus for adjacent pieces)
             */
            function evaluateConnectivity(aiId) {
                let score = 0;
                const rows = gameState.settings.rows;
                const cols = gameState.settings.cols;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (gameState.board[r][c] === aiId) {
                            // Check adjacent positions
                            const directions = [
                                [0, 1], [1, 0], [1, 1], [1, -1],
                                [0, -1], [-1, 0], [-1, -1], [-1, 1]
                            ];

                            for (const [dr, dc] of directions) {
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
                                    gameState.board[nr][nc] === aiId) {
                                    score += 1;
                                }
                            }
                        }
                    }
                }

                return score;
            }

            /**
             * Penalizes isolated pieces
             */
            function evaluateIsolation(aiId) {
                let isolatedPieces = 0;
                const rows = gameState.settings.rows;
                const cols = gameState.settings.cols;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (gameState.board[r][c] === aiId) {
                            let hasNeighbor = false;
                            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];

                            for (const [dr, dc] of directions) {
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
                                    gameState.board[nr][nc] === aiId) {
                                    hasNeighbor = true;
                                    break;
                                }
                            }

                            if (!hasNeighbor) isolatedPieces++;
                        }
                    }
                }

                return isolatedPieces;
            }

            /**
             * Evaluates positional advantages
             */
            function evaluatePositionalAdvantages(aiId) {
                let score = 0;
                const rows = gameState.settings.rows;
                const cols = gameState.settings.cols;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (gameState.board[r][c] === aiId) {
                            // Prefer lower rows (more stable)
                            score += (rows - r);

                            // Prefer positions that control key areas
                            if (r < rows - 1 && gameState.board[r + 1][c] !== 0) {
                                score += 2; // Supported piece bonus
                            }
                        }
                    }
                }

                return score;
            }

            function checkForTerminalState() {
                for (let r = 0; r < gameState.settings.rows; r++) {
                    for (let c = 0; c < gameState.settings.cols; c++) {
                        if (gameState.board[r][c] !== 0) {
                            const winner = checkWin(r, c);
                            if (winner) {
                                return { isTerminal: true, winner: winner.id - 1 };
                            }
                        }
                    }
                }
                if (isBoardFull()) {
                    return { isTerminal: true, winner: null };
                }
                return { isTerminal: false, winner: null };
            }

            // Keep original functions for compatibility
            function evaluateWindow(window, aiId) {
                return evaluateWindowAdvanced(window, aiId);
            }

            function evaluateBoard(aiId) {
                return evaluateBoardAdvanced(aiId);
            }

            function minimax(depth, isMaximizing, alpha, beta, originalAI) {
                return minimaxAdvanced(depth, isMaximizing, alpha, beta, originalAI);
            }
            // --- Game Controls ---
            function togglePause() {
                if (gameState.gameOver) return;

                gameState.isPaused = !gameState.isPaused;
                elements.pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';

                if (gameState.isPaused) {
                    // Store timer states but don't clear the actual time values
                    gameState.timers.gamePaused = gameState.timers.gameTimerId !== null;
                    gameState.timers.turnPaused = gameState.timers.turnTimerId !== null;

                    // Clear the intervals
                    clearTimers();
                } else {
                    // Resume timers based on stored states
                    if (gameState.settings.gameMode === 'timed') {
                        if (gameState.timers.gamePaused && gameState.timers.remainingGameTime > 0) {
                            startGameTimer();
                        }
                        if (gameState.timers.turnPaused && gameState.timers.remainingTurnTime > 0) {
                            startTurnTimer();
                        }
                    }
                    // Reset pause states
                    gameState.timers.gamePaused = false;
                    gameState.timers.turnPaused = false;
                }
                updateDisplay();
            }

            // Ensure your timer functions are set up to be called multiple times
            // and handle clearing previous intervals if they are called when one is already running.

            function startGameTimer() {
                // Clear any existing interval before setting a new one to prevent duplicates
                if (gameState.timers.gameTimerId) {
                    clearInterval(gameState.timers.gameTimerId);
                }
                gameState.timers.gameTimerId = setInterval(() => {
                    if (gameState.gameOver) { // Only check for game over, isPaused is handled in togglePause
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                        return;
                    }
                    gameState.timers.remainingGameTime--;
                    updateTimerDisplay();
                    if (gameState.timers.remainingGameTime <= 0) {
                        clearInterval(gameState.timers.gameTimerId);
                        gameState.timers.gameTimerId = null;
                        endGame("Time's up! It's a draw!");
                    }
                }, 1000);
            }


            function undoMove() {
                if (gameState.moveHistory.length === 0 || gameState.gameOver) return;
                const lastMove = gameState.moveHistory.pop();
                gameState.board = lastMove.boardState;
                gameState.turnsTaken[lastMove.player]--;
                gameState.currentPlayerIndex = lastMove.player;
                gameState.winningCells = [];
                renderBoard(); // Re-render to reflect undone move
                updateMoveHistory();
                elements.undoBtn.disabled = gameState.moveHistory.length === 0;
                updateDisplay();
            }

            function showHint() {
                if (gameState.gameOver || gameState.isPaused) return;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                if (currentPlayer.isAI) return;

                document.querySelectorAll('.hint-highlight').forEach(el => {
                    el.classList.remove('hint-highlight');
                });

                const col = getMediumAIMove();
                if (col !== -1) {
                    gameState.lastHintColumn = col;
                    for (let r = 0; r < gameState.settings.rows; r++) {
                        const cell = elements.gameBoard.querySelector(`[data-row='${r}'][data-col='${col}']`);
                        if (cell) {
                            cell.classList.add('column-highlight'); // Use class for highlight
                            setTimeout(() => {
                                cell.classList.remove('column-highlight');
                            }, 2000);
                        }
                    }
                }
            }

            function saveGame() {
                if (!gameState.isPaused && !gameState.gameOver) {
                    alert('Please pause the game before saving.');
                    return;
                }
                try {
                    const saveData = {
                        version: SAVE_FILE_VERSION,
                        gameState: gameState,
                        timestamp: new Date().toISOString()
                    };
                    const blob = new Blob([JSON.stringify(saveData, null, 2)], {
                        type: 'application/json'
                    });
                    const now = new Date();
                    const timestamp = now.toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
                    const filename = `connect4_${gameState.settings.gameMode}_${timestamp}.json`;
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                } catch (error) {
                    console.error('Save failed:', error);
                    alert('Failed to save game. Please try again.');
                }
            }

            function loadGame(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const saveData = JSON.parse(e.target.result);
                        if (!saveData.version || !saveData.gameState) {
                            throw new Error('Invalid save file format');
                        }
                        if (saveData.version !== SAVE_FILE_VERSION) {
                            if (!confirm('This save file is from a different version. Loading may cause issues. Continue?')) {
                                return;
                            }
                        }
                        cleanupGame();
                        gameState = saveData.gameState;

                        // Restore UI settings
                        elements.boardRowsInput.value = gameState.settings.rows;
                        elements.boardColsInput.value = gameState.settings.cols;
                        elements.winConditionInput.value = gameState.settings.winCondition;
                        elements.enableDiagonalCheckbox.checked = gameState.settings.enableDiagonal;
                        elements.gameModeSelect.value = gameState.settings.gameMode;
                        elements.timeLimitSelect.value = gameState.settings.timeLimit;
                        elements.turnTimeLimitSelect.value = gameState.settings.turnTimeLimit;
                        elements.turnLimitInput.value = gameState.settings.turnLimit;
                        elements.playerModeSelect.value = gameState.settings.playerMode;

                        updateGameModeOptionsVisibility();
                        updatePlayerInputs();

                        // Restore board color
                        elements.boardVisualLayer.style.backgroundColor = elements.boardColorSelect.value;

                        renderBoard(); // Re-render board with new settings and mask
                        updateMoveHistory();
                        updateDisplay();

                        if (gameState.settings.gameMode === 'timed' && !gameState.gameOver) {
                            if (!gameState.isPaused) {
                                startGameTimer();
                                if (gameState.settings.turnTimeLimit > 0) {
                                    startTurnTimer();
                                }
                            }
                        }
                        elements.pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';
                        elements.undoBtn.disabled = gameState.moveHistory.length === 0;
                        event.target.value = '';
                        alert('Game loaded successfully!');

                    } catch (error) {
                        console.error('Load failed:', error);
                        alert('Failed to load game file. Please check the file and try again.');
                    }
                };
                reader.readAsText(file);
            }

            document.querySelectorAll('details').forEach(details => {
                const content = details.querySelector('.details-content');

                details.addEventListener('toggle', () => {
                    if (details.open) {
                        // Measure content height and set CSS variable
                        const height = content.scrollHeight;
                        details.style.setProperty('--content-height', height + 'px');
                    }
                });
            });

            // --- Initialize Game ---
            init();
        });
    </script>
</body>

</html>